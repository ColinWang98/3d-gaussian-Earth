<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HK 3DGS Hub | Pro Holographic Map</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #ffffff;
            --danger: #f5f5f5;
            --glass: rgba(5, 5, 5, 0.9);
            --accent: #f5f5f5;
            --transition-base: 200ms cubic-bezier(0.4, 0, 0.2, 1);
        }
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        body, html { margin: 0; padding: 0; height: 100%; background: #000; font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; overflow: hidden; color: #f5f5f5; }
        h1, h2, h3, #app-title { font-family: 'Space Grotesk', sans-serif; }
        #map-background { position: absolute; inset: 0; z-index: 1; }
        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 1000; }
        .pointer-auto { pointer-events: auto; }
        #app-title { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: #f5f5f5; font-size: 28px; font-weight: 300; letter-spacing: 2px; z-index: 1001; pointer-events: none; text-shadow: 0 2px 10px rgba(0,0,0,0.6); }
        #lang-toggle,
        #map-style-toggle {
            position: absolute;
            top: 20px;
            background: rgba(255,255,255,0.03);
            color: #f5f5f5;
            border: 1px solid #444;
            padding: 10px 16px;
            min-height: 44px;
            min-width: 44px;
            border-radius: 999px;
            cursor: pointer;
            z-index: 1001;
            font-size: 0.9em;
            transition: background-color var(--transition-base), border-color var(--transition-base), color var(--transition-base);
        }
        #lang-toggle:focus-visible,
        #map-style-toggle:focus-visible {
            outline: 2px solid #f5f5f5;
            outline-offset: 2px;
        }
        #lang-toggle:hover,
        #map-style-toggle:hover {
            background: rgba(255,255,255,0.08);
            border-color: #666;
        }
        #lang-toggle { left: 20px; }
        #map-style-toggle { left: 110px; }
        #upload-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #f5f5f5;
            border: 1px solid #f5f5f5;
            padding: 12px 24px;
            min-height: 44px;
            border-radius: 999px;
            color: #000;
            font-weight: 500;
            cursor: pointer;
            z-index: 1001;
            letter-spacing: 0.03em;
            transition: background-color var(--transition-base), transform var(--transition-base);
        }
        #upload-btn:focus-visible {
            outline: 2px solid #f5f5f5;
            outline-offset: 2px;
        }
        #upload-btn:hover {
            background: #ffffff;
            transform: translateY(-1px);
        }
        #upload-btn:active {
            transform: translateY(0);
        }
        #info-bar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 450px;
            background: var(--glass);
            padding: 18px 20px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.12);
            color: #f5f5f5;
            display: none;
        }
        #splat-viewer { position: absolute; inset: 0; background: transparent; z-index: 9999; display: none; }
        /* 确保 splat-viewer 本身不阻挡鼠标事件，只有子元素可以交互
           允许返回按钮、效果控制面板、语言切换按钮和聊天窗口接收鼠标事件 */
        #splat-viewer > *:not(canvas):not(#close-splat):not(#chat-window):not(#effect-controls):not(#view-lang-toggle):not(#chat-toggle-btn) { pointer-events: none; }
        #close-splat {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 2100;
            padding: 12px 20px;
            min-height: 44px;
            border-radius: 999px;
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid white;
            cursor: pointer;
            pointer-events: auto;
            transition: background-color var(--transition-base), border-color var(--transition-base);
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        #close-splat:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }
        #close-splat:hover {
            background: rgba(255,255,255,0.3);
        }
        .icon {
            width: 20px;
            height: 20px;
            display: inline-block;
            flex-shrink: 0;
        }
        button {
            transition: background-color var(--transition-base), border-color var(--transition-base), color var(--transition-base), transform var(--transition-base);
        }
        button:focus-visible {
            outline: 2px solid #f5f5f5;
            outline-offset: 2px;
        }
        button[style*="background:#f5f5f5"]:hover {
            background: #ffffff !important;
            transform: translateY(-1px);
        }
        button[style*="background:#111"]:hover {
            background: #1a1a1a !important;
        }
        #effect-controls { position: absolute; top: 20px; left: 200px; z-index: 2100; background: var(--glass); border-radius: 15px; border: 1px solid #333; padding: 15px; min-width: 200px; pointer-events: auto; display: none; }
        #effect-controls label { color: white; font-size: 0.9em; display: block; margin-bottom: 8px; }
        #effect-select {
            width: 100%;
            padding: 8px;
            background: #0b0b0b;
            border: 1px solid #444;
            color: #f5f5f5;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 10px;
        }
        #intensity-control { margin-bottom: 10px; }
        #intensity-control label { display: block; margin-bottom: 5px; }
        #intensity-slider { width: 100%; }
        #reset-time-btn {
            width: 100%;
            padding: 12px;
            min-height: 44px;
            background: transparent;
            border: 1px solid #555;
            color: #f5f5f5;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85em;
            margin-bottom: 10px;
            transition: background-color var(--transition-base), border-color var(--transition-base);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        #reset-time-btn:focus-visible {
            outline: 2px solid #f5f5f5;
            outline-offset: 2px;
        }
        #reset-time-btn:hover {
            background: rgba(255,255,255,0.05);
            border-color: #666;
        }
        #audiuno-controls { margin-top: 10px; padding-top: 10px; border-top: 1px solid #333; }
        #audiuno-status { font-size: 0.8em; color: #aaa; margin-bottom: 5px; }
        #connect-audiuno-btn {
            width: 100%;
            padding: 12px;
            min-height: 44px;
            background: transparent;
            border: 1px solid #555;
            color: #f5f5f5;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: background-color var(--transition-base), border-color var(--transition-base);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        #connect-audiuno-btn:focus-visible {
            outline: 2px solid #f5f5f5;
            outline-offset: 2px;
        }
        #connect-audiuno-btn:hover {
            background: rgba(255,255,255,0.05);
            border-color: #666;
        }
        #audiuno-toggle-row { margin-top: 8px; display: flex; align-items: center; gap: 8px; color: #ddd; font-size: 0.85em; }
        #audiuno-toggle-row input { width: auto; margin: 0; }
        #heart-rate-display { font-size: 0.9em; color: #f5f5f5; margin-top: 5px; }
        #view-lang-toggle {
            position: absolute;
            top: 20px;
            right: 360px;
            z-index: 2100;
            padding: 10px 20px;
            min-height: 44px;
            border-radius: 999px;
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid white;
            cursor: pointer;
            pointer-events: auto;
            display: none;
            transition: background-color var(--transition-base), border-color var(--transition-base);
        }
        #view-lang-toggle:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }
        #view-lang-toggle:hover {
            background: rgba(255,255,255,0.3);
        }
        /* 为了确保 3D 画布可交互，聊天窗口不拦截鼠标事件 */
        #chat-window {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 320px;
            height: 400px;
            max-height: 70vh;
            background: var(--glass);
            border-radius: 16px;
            border: 1px solid #333;
            display: none;
            flex-direction: column;
            z-index: 2100;
            box-shadow: 0 12px 40px rgba(0,0,0,0.8);
            overflow: hidden;
        }
        #chat-msgs { flex: 1; padding: 12px; overflow-y: auto; font-size: 0.85em; color: #eee; display: flex; flex-direction: column; gap: 10px; }
        .msg { padding: 10px 14px; border-radius: 12px; max-width: 85%; border: 1px solid #333; }
        .msg-agent { background: #111; align-self: flex-start; }
        .msg-user { background: #1f1f1f; align-self: flex-end; }
        #chat-input-wrap { display: flex; border-top: 1px solid #333; padding: 10px; background: rgba(0,0,0,0.3); }
        #chat-input { flex: 1; background: transparent; border: none; color: white; outline: none; }
        #modal-overlay { display: none; position: absolute; inset: 0; background: rgba(0,0,0,0.85); justify-content: center; align-items: center; z-index: 3000; pointer-events: auto; }
        .modal-box {
            background: #050505;
            padding: 24px;
            border-radius: 16px;
            width: 90%;
            max-width: 400px;
            color: #f5f5f5;
            border: 1px solid #333;
        }
        input, textarea {
            width: 100%;
            box-sizing: border-box;
            background: #0b0b0b;
            border: 1px solid #444;
            color: #f5f5f5;
            padding: 12px;
            min-height: 44px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 16px;
            transition: border-color var(--transition-base), background-color var(--transition-base);
        }
        input:focus, textarea:focus {
            outline: none;
            border-color: #f5f5f5;
            background: #111;
        }
        input::placeholder, textarea::placeholder {
            color: #666;
        }
        /* 加载提示：改为右上角小徽标，而不是全屏遮罩，且不拦截交互 */
        #loading-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            min-width: 160px;
            padding: 6px 14px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 12px;
            z-index: 2100;
            pointer-events: none;
        }
        /* 确保所有 canvas 都可以交互，主渲染 canvas 在最上层 */
        #splat-viewer canvas { pointer-events: auto !important; position: absolute !important; top: 0 !important; left: 0 !important; width: 100% !important; height: 100% !important; z-index: 100 !important; }

        /* AI 聊天折叠按钮 */
        #chat-toggle-btn {
            position: absolute;
            top: 20px;
            right: 140px;
            z-index: 2101;
            padding: 10px 16px;
            min-height: 44px;
            border-radius: 999px;
            background: rgba(255,255,255,0.04);
            color: #f5f5f5;
            border: 1px solid #444;
            cursor: pointer;
            pointer-events: auto;
            font-size: 0.85em;
            letter-spacing: 0.04em;
            transition: background-color var(--transition-base), border-color var(--transition-base);
        }
        #chat-toggle-btn:focus-visible {
            outline: 2px solid #f5f5f5;
            outline-offset: 2px;
        }
        #chat-toggle-btn:hover {
            background: rgba(255,255,255,0.08);
            border-color: #666;
        }

        /* 移动端适配 */
        @media (max-width: 768px) {
            #app-title {
                top: 10px;
                font-size: 20px;
            }
            #lang-toggle, #map-style-toggle, #upload-btn {
                padding: 6px 10px;
                font-size: 12px;
            }
            #map-style-toggle {
                left: 80px;
            }
            #upload-btn {
                top: 60px;
                right: 10px;
                padding: 8px 14px;
            }
            #info-bar {
                bottom: 10px;
                width: 94%;
                padding: 12px;
            }
            #effect-controls {
                top: auto;
                bottom: 80px;
                left: 10px;
                right: 10px;
                min-width: 0;
                width: auto;
            }
            #view-lang-toggle {
                top: 20px;
                right: 20px;
            }
            #chat-window {
                left: 0;
                right: 0;
                bottom: 0;
                width: 100%;
                height: 45vh;
                border-radius: 16px 16px 0 0;
            }
            #chat-toggle-btn {
                top: 20px;
                right: 20px;
            }
        }
    </style>
    <script type="importmap">{ "imports": { 
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.178.0/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/",
            "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.10/spark.module.js",
            "@huggingface/hub": "https://cdn.jsdelivr.net/npm/@huggingface/hub@0.15.1/+esm"
    }}</script>
</head>
<body>
    <div id="map-background"></div>
    <div id="splat-viewer" class="pointer-auto">
        <div id="loading-overlay"></div>
        <button id="close-splat" aria-label="返回地图">
            <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
            </svg>
            <span>返回地图</span>
        </button>
        <div id="effect-controls">
            <label for="effect-select">视觉效果：</label>
            <select id="effect-select">
                <option value="None">无效果</option>
                <optgroup label="Reveal Effects">
                    <option value="Magic">魔法</option>
                    <option value="Spread">扩散</option>
                    <option value="Unroll">展开</option>
                    <option value="Twister">龙卷风</option>
                    <option value="Rain">雨</option>
                </optgroup>
                <optgroup label="Shader Effects">
                    <option value="Waves">波浪</option>
                    <option value="Disintegrate">分解</option>
                </optgroup>
            </select>
            <div id="intensity-control" style="display: none;">
                <label for="intensity-slider">强度: <span id="intensity-value">0.8</span></label>
                <input type="range" id="intensity-slider" min="0" max="1" step="0.01" value="0.8">
            </div>
            <button id="reset-time-btn" aria-label="重置时间">
                <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                </svg>
                <span>重置时间</span>
            </button>
            <div id="audiuno-controls">
                <div id="audiuno-status">未连接</div>
                <button id="connect-audiuno-btn" aria-label="连接 Audiuno">
                    <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.111 16.404a5.5 5.5 0 017.778 0M12 20h.01m-7.08-7.071c3.904-3.905 10.236-3.905 14.141 0M1.394 9.393c5.857-5.857 15.355-5.857 21.213 0"></path>
                    </svg>
                    <span>连接 Audiuno</span>
                </button>
                <div id="audiuno-toggle-row">
                    <input type="checkbox" id="use-heartbeat-toggle" checked>
                    <label for="use-heartbeat-toggle" id="use-heartbeat-label">接受心跳数据</label>
                </div>
                <div id="heart-rate-display" style="display: none;">心率: <span id="heart-rate-value">--</span> BPM</div>
            </div>
        </div>
        <button id="view-lang-toggle">EN / 中</button>
        <button id="chat-toggle-btn">探索记忆</button>
        <div id="chat-window">
            <div id="gemini-config-ui" style="padding:20px; text-align:center;">
                <p style="color:#f5f5f5; font-size:0.9em; letter-spacing:0.04em;">激活 AI 导览员</p>
                <input type="password" id="user-gemini-key" placeholder="Gemini API Key...">
                <button id="save-key-btn" style="background:#f5f5f5; color:#000; border:1px solid #f5f5f5; padding:10px; width:100%; border-radius:999px; cursor:pointer; font-weight:500;">开启 AI 对话</button>
            </div>
            <div id="chat-main-ui" style="display:none; flex-direction:column; height:100%;">
                <div id="chat-msgs"></div>
                <div id="chat-input-wrap">
                    <input type="text" id="chat-input" placeholder="提问...">
                    <button id="chat-send" style="background:none; border:none; color:var(--primary); cursor:pointer;">发送</button>
                </div>
            </div>
        </div>
    </div>

    <div id="ui-layer">
        <h1 id="app-title">Spatial Memory Map</h1>
        <button id="lang-toggle" class="pointer-auto">EN / 中</button>
        <button id="map-style-toggle" class="pointer-auto" aria-label="地图样式">
            <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true" style="width: 16px; height: 16px;">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"></path>
            </svg>
            <span>地图样式</span>
        </button>
        <button id="upload-btn" class="pointer-auto" aria-label="新增任务">
            <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true" style="width: 18px; height: 18px;">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
            </svg>
            <span>新增任务</span>
        </button>
        <div id="info-bar" class="pointer-auto">
            <h3 id="loc-title" style="margin:0"></h3>
            <p id="loc-desc" style="color:#aaa; font-size:0.85em; margin:10px 0;"></p>
            <div style="display:flex; justify-content:space-between; gap:10px;">
                <button id="del-btn" style="background:#111; border:1px solid #444; padding:8px 16px; border-radius:999px; color:#f5f5f5; cursor:pointer; font-weight:500;">删除</button>
                <button id="enter-btn" style="background:#f5f5f5; border:1px solid #f5f5f5; padding:10px 24px; border-radius:999px; cursor:pointer; font-weight:500; color:#000;">全息查看</button>
            </div>
        </div>
    </div>

    <div id="modal-overlay">
        <div class="modal-box">
            <h3 style="margin:0 0 15px 0; font-weight:400;">创建重建任务</h3>
            <input type="password" id="hf-token" placeholder="Hugging Face Write Token">
            <input type="text" id="loc-name" placeholder="地点名称 (中文)">
            <input type="text" id="loc-name-en" placeholder="Location Name (English，留空将自动翻译)">
            <div style="display:flex; gap:8px;">
                <input type="text" id="lat-lon" readonly placeholder="点击地图拾取坐标">
                <button id="pick-btn" style="background:#111; border:1px solid #444; padding:0 16px; border-radius:999px; color:#f5f5f5; cursor:pointer;">拾取</button>
            </div>
            <input type="file" id="photo-input" accept="image/*">
            <textarea id="desc-input" rows="2" placeholder="请输入描述 (中文，将自动翻译为英文)..."></textarea>
            <button id="submit-btn" style="width:100%; background:#f5f5f5; border:1px solid #f5f5f5; padding:12px; border-radius:999px; font-weight:500; cursor:pointer; margin-top:10px; color:#000;">上传任务</button>
            <button onclick="document.getElementById('modal-overlay').style.display='none'" style="width:100%; background:none; border:none; color:#888; margin-top:10px; cursor:pointer;">取消</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
    <!-- 公共配置（随 GitHub Pages 发布）：只放非敏感配置，如 Cloud Run URL -->
    <script src="config.js"></script>
    <!-- 本地私密配置（可选）：存在则覆盖公共配置；GitHub Pages 上通常不存在，因此用 onerror 静默 -->
    <script src="config.local.js" onerror="console.info('config.local.js not found (expected on GitHub Pages)')"></script>
    <script type="module">
        import { commit } from '@huggingface/hub';
        import * as THREE from 'three';
        import { SparkControls, SplatMesh, dyno } from '@sparkjsdev/spark';

        const REPO_ID = "ColinWong24/my-gaussian-world";
            const state = { 
                locations: [], 
                currentLoc: null, 
                lang: 'cn', 
                scene: null, 
                camera: null, 
                renderer: null, 
                controls: null, 
                splatMesh: null, 
                animationId: null, 
                resizeHandler: null, 
                isPicking: false, 
                selectedCoords: null, 
                deeplKey: localStorage.getItem('DEEPL_KEY') || '', 
                effectParams: { effect: 'None', intensity: 0.8 }, 
                animateT: null, 
                baseTime: 0, 
                effectStartTime: 0, 
                modelCenter: null, 
                audiuno: { 
                    port: null, 
                    reader: null, 
                    heartRate: 0, 
                    isConnected: false, 
                    usePhysiological: true, 
                    lastHeartbeatTime: 0, 
                    heartbeatTimes: [], 
                    heartbeatPeaks: [] 
                }, 
                isInitializing: false, 
                isChatOpen: false,
                isParticleMode: false,
                viewerKeyHandler: null,
                prevEffectForParticle: null,
                // 3D viewer 鼠标信息（用于粒子模式扰动）
                mouse: {
                    worldX: 0,
                    worldY: 0,
                    worldZ: 0,
                    lastTime: -1 // 使用 effectTime 作为时间轴；<0 表示当前没有激活的轨迹
                }
            };
        let ACTIVE_GEMINI_KEY = localStorage.getItem('MY_GEMINI_KEY') || '';
        
        // DeepL 自动翻译函数
        async function translateWithDeepL(text, targetLang = 'EN') {
            if (!state.deeplKey || !text) return text;
            try {
                const res = await fetch('https://api-free.deepl.com/v2/translate', {
                    method: 'POST',
                    headers: {
                        'Authorization': `DeepL-Auth-Key ${state.deeplKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: [text],
                        target_lang: targetLang
                    })
                });
                if (!res.ok) throw new Error(`DeepL API 错误: ${res.status}`);
                const data = await res.json();
                return data.translations[0].text;
            } catch (e) {
                console.warn('DeepL 翻译失败:', e);
                return text; // 翻译失败时返回原文
            }
        }

        function updateLangUI() {
            const langBtn = document.getElementById('lang-toggle');
            if (langBtn) langBtn.innerText = state.lang === 'cn' ? 'EN / 中' : '中 / EN';

            // 顶部/地图相关按钮
            const uploadBtn = document.getElementById('upload-btn');
            if (uploadBtn) {
                const span = uploadBtn.querySelector('span');
                if (span) span.textContent = state.lang === 'cn' ? '新增任务' : 'New Task';
            }

            const delBtn = document.getElementById('del-btn');
            if (delBtn) delBtn.innerText = state.lang === 'cn' ? '删除' : 'Delete';

            const enterBtn = document.getElementById('enter-btn');
            if (enterBtn) enterBtn.innerText = state.lang === 'cn' ? '全息查看' : 'Enter 3D View';

            // 创建任务弹窗内按钮与标题
            const modalTitle = document.querySelector('#modal-overlay .modal-box h3');
            if (modalTitle) modalTitle.innerText = state.lang === 'cn' ? '创建重建任务' : 'Create Reconstruction Task';

            const pickBtn = document.getElementById('pick-btn');
            if (pickBtn) pickBtn.innerText = state.lang === 'cn' ? '拾取' : 'Pick';

            const submitBtn = document.getElementById('submit-btn');
            if (submitBtn) submitBtn.innerText = state.lang === 'cn' ? '上传任务' : 'Upload Task';

            const cancelBtn = document.querySelector('#modal-overlay button[onclick]');
            if (cancelBtn) cancelBtn.innerText = state.lang === 'cn' ? '取消' : 'Cancel';

            // 3D 视图相关按钮
            const closeSplat = document.getElementById('close-splat');
            if (closeSplat) {
                const span = closeSplat.querySelector('span');
                if (span) span.textContent = state.lang === 'cn' ? '返回地图' : 'Back to Map';
            }

            const resetTimeBtn = document.getElementById('reset-time-btn');
            if (resetTimeBtn) {
                const span = resetTimeBtn.querySelector('span');
                if (span) span.textContent = state.lang === 'cn' ? '重置时间' : 'Reset Time';
            }

            const connectAudiunoBtn = document.getElementById('connect-audiuno-btn');
            if (connectAudiunoBtn && !state.audiuno.isConnected) {
                const span = connectAudiunoBtn.querySelector('span');
                if (span) span.textContent = state.lang === 'cn' ? '连接 Audiuno' : 'Connect Audiuno';
            }

            const useHeartbeatLabel = document.getElementById('use-heartbeat-label');
            if (useHeartbeatLabel) useHeartbeatLabel.innerText = state.lang === 'cn' ? '接受心跳数据' : 'Use heartbeat data';

            const chatToggleBtn = document.getElementById('chat-toggle-btn');
            if (chatToggleBtn) chatToggleBtn.innerText = state.lang === 'cn' ? '探索记忆' : 'Explore Memory';

            const chatSendBtn = document.getElementById('chat-send');
            if (chatSendBtn) chatSendBtn.innerText = state.lang === 'cn' ? '发送' : 'Send';

            // Gemini 配置区域按钮与提示
            const geminiTitle = document.querySelector('#gemini-config-ui p');
            if (geminiTitle) {
                geminiTitle.innerText = state.lang === 'cn'
                    ? '激活 AI 导览员'
                    : 'Activate AI Guide';
            }
            const geminiInput = document.getElementById('user-gemini-key');
            if (geminiInput) {
                geminiInput.placeholder = state.lang === 'cn'
                    ? 'Gemini API Key...'
                    : 'Gemini API Key...';
            }
            const geminiBtn = document.getElementById('save-key-btn');
            if (geminiBtn) {
                geminiBtn.innerText = state.lang === 'cn'
                    ? '开启 AI 对话'
                    : 'Start AI Chat';
            }

            // 根据语言切换当前地点标题和描述（如果有英文字段）
            if (state.currentLoc) {
                const loc = state.currentLoc;
                const titleEl = document.getElementById('loc-title');
                const descEl = document.getElementById('loc-desc');
                if (state.lang === 'cn') {
                    titleEl.innerText = loc.name || '';
                    descEl.innerText = loc.desc || '处理中...';
                } else {
                    titleEl.innerText = loc.name_en || loc.name || '';
                    descEl.innerText = loc.desc_en || loc.desc || 'Processing...';
                }
            }

            // 同步更新地图样式按钮的文案
            updateMapStyleButton();
        }

        // ===== AI 聊天相关 =====
        function addChatMessage(role, text) {
            const msgs = document.getElementById('chat-msgs');
            if (!msgs) return;
            const div = document.createElement('div');
            div.className = `msg msg-${role}`;
            div.innerText = text;
            msgs.appendChild(div);
            msgs.scrollTop = msgs.scrollHeight;
        }

        function clearChatMemory() {
            const msgs = document.getElementById('chat-msgs');
            if (msgs) msgs.innerHTML = '';
            // 重置“是否已欢迎过”标记，保证每个场景只欢迎一次
            state.chatGreeted = false;
        }

        function showChatUI() {
            const chatWin = document.getElementById('chat-window');
            if (!chatWin) return;
            chatWin.style.display = 'flex';
            state.isChatOpen = true;

            const cfg = document.getElementById('gemini-config-ui');
            const main = document.getElementById('chat-main-ui');

            // 场景切换时清空对话记忆（按场景隔离）
            const sceneKey = (state.currentLoc && (state.currentLoc.id || state.currentLoc.photoPath || `${state.currentLoc.lat},${state.currentLoc.lon}`)) || '';
            if (state.chatSceneKey !== sceneKey) {
                clearChatMemory();
                state.chatSceneKey = sceneKey;
            }

            if (ACTIVE_GEMINI_KEY) {
                cfg.style.display = 'none';
                main.style.display = 'flex';
                // 当前场景只打招呼一次，避免重复自我介绍
                if (!state.chatGreeted && state.currentLoc) {
                    const locName = state.lang === 'cn'
                        ? (state.currentLoc.name || state.currentLoc.name_en || '这个地方')
                        : (state.currentLoc.name_en || state.currentLoc.name || 'this place');
                    if (state.lang === 'cn') {
                        addChatMessage('agent', `这是我当时记录下来的一个记忆场景：${locName}。你可以直接问我这里的细节、当时的心情，或者附近有什么值得看的。`);
                    } else {
                        addChatMessage('agent', `This is a memory scene I captured: ${locName}. Ask me about details here, how I felt then, or what’s interesting nearby.`);
                    }
                    state.chatGreeted = true;
                }
            } else {
                cfg.style.display = 'block';
                main.style.display = 'none';
            }
        }

        // 折叠 / 展开 AI 聊天窗口
        const chatToggleBtn = document.getElementById('chat-toggle-btn');
        if (chatToggleBtn) {
            chatToggleBtn.addEventListener('click', () => {
                const chatWin = document.getElementById('chat-window');
                if (!chatWin) return;
                const isHidden = chatWin.style.display === 'none' || chatWin.style.display === '';
                if (isHidden) {
                    showChatUI();
                } else {
                    chatWin.style.display = 'none';
                    state.isChatOpen = false;
                }
            });
        }

        // 将图片 URL 转换为 base64
        async function imageUrlToBase64(imageUrl) {
            try {
                const response = await fetch(imageUrl);
                const blob = await response.blob();
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const base64 = reader.result.split(',')[1]; // 移除 data:image/...;base64, 前缀
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (e) {
                console.error('图片转换失败:', e);
                return null;
            }
        }

        // 检测文本语言（简单检测：包含中文字符则为中文）
        function detectLanguage(text) {
            // 检测是否包含中文字符
            const chineseRegex = /[\u4e00-\u9fa5]/;
            return chineseRegex.test(text) ? 'cn' : 'en';
        }

        async function handleChat() {
            // AI Provider:
            // - 默认：Gemini API Key 直连（不推荐在生产环境暴露 key）
            // - 可选：Vertex AI 代理（推荐）：由本地/云端代理服务安全调用 Vertex AI（无需在前端暴露凭据）
            // - 可选：ADK/自建 HTTP 服务（方案A）：由你自己的服务调用云端模型，再返回给前端
            // 选择 AI Provider（优先走自建/云端服务，避免浏览器直连 Google 域名导致模型/版本不兼容）
            const AI_PROVIDER =
                (window.LOCAL_CONFIG && window.LOCAL_CONFIG.AI_PROVIDER) ? window.LOCAL_CONFIG.AI_PROVIDER :
                (window.LOCAL_CONFIG && window.LOCAL_CONFIG.ADK_CHAT_URL) ? 'adk' :
                (window.LOCAL_CONFIG && window.LOCAL_CONFIG.VERTEX_PROXY_URL) ? 'vertex' :
                'gemini';

            if (AI_PROVIDER === 'gemini' && !ACTIVE_GEMINI_KEY) {
                alert('请先在右下角输入 Gemini API Key（或在 config.local.js 配置 ADK_CHAT_URL 走 Cloud Run / 自建服务）');
                return;
            }
            const input = document.getElementById('chat-input');
            const text = (input.value || '').trim();
            if (!text) return;
            addChatMessage('user', text);
            input.value = '';

            // 检测用户输入的语言
            const userLang = detectLanguage(text);

            const loc = state.currentLoc || {};
            const locName = userLang === 'cn' ? (loc.name || loc.name_en || '这个地方') : (loc.name_en || loc.name || 'this place');
            const locDesc = userLang === 'cn' ? (loc.desc || loc.desc_en || '') : (loc.desc_en || loc.desc || '');
            
            // 根据用户语言生成系统提示词
            const sys = userLang === 'cn' 
                ? `你是这张照片的拍摄者，也是这个 3D 全息场景的创建者。用户正在查看你拍摄并重建的场景。

你的身份：照片提供者
场景地点：${locName}
场景描述：${locDesc}

请以照片拍摄者的第一人称身份，用口语化、亲切的方式与用户聊天。你可以：
- 分享拍摄这个场景时的经历和感受
- 描述场景中的细节和特色
- 回答用户关于场景的问题
- 基于照片内容提供更多背景信息

回答要简短、自然，多用"唔"、"啊"、"其实"、"当时"等口语化表达，就像和朋友聊天一样。
尤其注意：
- 只在最开始简单欢迎一次即可，后续对话不要再重复“你好/欢迎你来看我拍的这个场景”之类的开场白。
- 不要在每一轮都重复说明“这是我去年八月在海港城拍的”“逛街逛着逛着看到夕阳”这类背景故事，除非用户明确要求你再讲拍摄经过。
- 当用户问“附近有什么”“还有什么景点吗”等问题时，优先列出周边可以去的地点/街景/体验，而不是继续长篇描述照片本身。
- 根据用户的提问直接给到重点内容，控制在几句话内，避免长篇大段重复描述。
请用中文回复。`
                : `You are the photographer of this photo and the creator of this 3D holographic scene. The user is viewing the scene you photographed and reconstructed.

Your identity: Photo provider
Location: ${locName}
Scene description: ${locDesc}

Please chat with the user in a casual, friendly way as the photographer in first person. You can:
- Share your experiences and feelings when photographing this scene
- Describe the details and features of the scene
- Answer questions about the scene
- Provide more background information based on the photo content

Keep your answers brief and natural, use casual expressions like "well", "actually", "at that time", just like chatting with a friend.
Do NOT repeat your self-introduction or the same story in every turn; only mention it briefly when truly helpful.
Answer the user’s question directly and focus on the key points instead of long repetitive descriptions. Please reply in English.`;

            try {
                // 构建请求的 parts 数组
                const parts = [{ text: sys }];
                
                // 如果有图片，添加到请求中
                let vertexImage = null;
                let vertexImageUrl = null;
                if (loc.photoPath) {
                    const imageUrl = `https://huggingface.co/datasets/${REPO_ID}/resolve/main/${loc.photoPath}`;
                    vertexImageUrl = imageUrl; // 交给后端拉取（更稳、更省内存）
                    // 仍保留本地 base64 兜底（某些部署不允许后端外网拉取时可开启）
                    if (window.LOCAL_CONFIG && window.LOCAL_CONFIG.ADK_SEND_IMAGE_AS_BASE64 === true) {
                        const base64Image = await imageUrlToBase64(imageUrl);
                        if (base64Image) {
                            // 根据文件扩展名确定 MIME 类型
                            const mimeType = loc.photoPath.toLowerCase().endsWith('.png') ? 'image/png' : 'image/jpeg';
                            parts.push({
                                inlineData: {
                                    mimeType: mimeType,
                                    data: base64Image
                                }
                            });
                            vertexImage = { mimeType, data: base64Image };
                        }
                    }
                }
                
                // 添加用户的问题
                parts.push({ text: text });

                let res = null;
                let data = null;
                if (AI_PROVIDER === 'adk') {
                    const adkEndpoint = (window.LOCAL_CONFIG && window.LOCAL_CONFIG.ADK_CHAT_URL)
                        ? window.LOCAL_CONFIG.ADK_CHAT_URL
                        : 'http://localhost:8010/api/chat';
                    const adkProvider = (window.LOCAL_CONFIG && window.LOCAL_CONFIG.ADK_PROVIDER)
                        ? window.LOCAL_CONFIG.ADK_PROVIDER
                        : 'vertex'; // vertex | gemini
                    const adkModel = (window.LOCAL_CONFIG && window.LOCAL_CONFIG.ADK_MODEL)
                        ? window.LOCAL_CONFIG.ADK_MODEL
                        : 'gemini-2.5-flash';
                    const adkApiKey = (window.LOCAL_CONFIG && window.LOCAL_CONFIG.ADK_API_KEY)
                        ? window.LOCAL_CONFIG.ADK_API_KEY
                        : '';
                    console.warn('使用 ADK/自建 HTTP 服务:', adkEndpoint, 'provider=', adkProvider, 'model=', adkModel);
                    const headers = { 'Content-Type': 'application/json' };
                    if (adkApiKey) headers['X-API-KEY'] = adkApiKey;

                    // “附近/周围/周边”等问题自动触发地图检索（200m + street view）
                    const nearbyRegex = /(附近|周围|周边|旁边|近处|around|nearby|surround|附近的情况|200\s*(米|m))/i;
                    const includeMaps = nearbyRegex.test(text);
                    const lat = (loc && typeof loc.lat === 'number') ? loc.lat : null;
                    const lng = (loc && typeof loc.lon === 'number') ? loc.lon : (loc && typeof loc.lng === 'number') ? loc.lng : null;

                    const payload = {
                        provider: adkProvider,
                        model: adkModel,
                        system: sys,
                        text,
                        imageUrl: vertexImageUrl,
                        image: vertexImage,
                        // 传给后端用于 Places + Street View 检索
                        lat,
                        lng,
                        includeMaps,
                        mapsRadiusM: 200
                    };

                    // 一次轻量重试（应对冷启动/偶发网络波动）
                    const doFetch = async () => fetch(adkEndpoint, {
                        method: 'POST',
                        headers,
                        body: JSON.stringify(payload)
                    });

                    res = await doFetch();
                    if (!res.ok) {
                        // 对 502/503/504 做一次重试
                        if (res.status === 502 || res.status === 503 || res.status === 504) {
                            await new Promise(r => setTimeout(r, 600));
                            res = await doFetch();
                        }
                    }

                    if (!res.ok) {
                        const errorData = await res.json().catch(() => ({}));
                        console.error('ADK/HTTP 服务错误:', res.status, errorData);
                        const detail = errorData.detail ? JSON.stringify(errorData.detail) : (errorData.error?.message || res.statusText);
                        let hint = '';
                        if (res.status === 401) hint = '（鉴权失败：检查 ADK_API_KEY / CHAT_API_KEY）';
                        else if (res.status === 403) hint = '（权限不足：检查 Cloud Run Service Account 是否有 Vertex AI User）';
                        else if (res.status === 429) hint = '（请求过多/限流：稍后重试）';
                        throw new Error(`API 错误 ${res.status}: ${detail}${hint}`);
                    }
                    const out = await res.json();
                    addChatMessage('agent', out.text || '(empty)');
                    return;
                } else if (AI_PROVIDER === 'vertex') {
                    const vertexEndpoint = (window.LOCAL_CONFIG && window.LOCAL_CONFIG.VERTEX_PROXY_URL)
                        ? window.LOCAL_CONFIG.VERTEX_PROXY_URL
                        : 'http://localhost:8787/api/vertex/generate';
                    const vertexModel = (window.LOCAL_CONFIG && window.LOCAL_CONFIG.VERTEX_MODEL)
                        ? window.LOCAL_CONFIG.VERTEX_MODEL
                        : 'gemini-2.5-flash';
                    console.warn('使用 Vertex AI 代理:', vertexEndpoint, 'model=', vertexModel);
                    res = await fetch(vertexEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: vertexModel,
                            system: sys,
                            text,
                            image: vertexImage
                        })
                    });
                    if (!res.ok) {
                        const errorData = await res.json().catch(() => ({}));
                        console.error('Vertex AI Proxy 错误:', res.status, errorData);
                        throw new Error(`API 错误 ${res.status}: ${errorData.detail ? JSON.stringify(errorData.detail) : (errorData.error?.message || res.statusText)}`);
                    }
                    data = await res.json();
                } else {
                    // 依次尝试多个模型（参考 Gemini 官方文档 https://ai.google.dev/gemini-api/docs）
                    // 注意：当前使用 v1beta 端点，只保留文档确认支持的 flash 系列，移除 1.5-pro 以避免 404
                    const modelCandidates = ['gemini-3-flash-preview', 'gemini-1.5-flash'];
                    let modelName = '';
                    for (let i = 0; i < modelCandidates.length; i++) {
                        modelName = modelCandidates[i];
                        console.warn('尝试调用 Gemini 模型:', modelName);
                        res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${ACTIVE_GEMINI_KEY}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [
                                    { role: 'user', parts: parts }
                                ]
                            })
                        });
                        if (res.ok) break;
                        // 只在 400/404 时降级到下一个模型，其它错误直接抛出
                        if (!(res.status === 400 || res.status === 404)) break;
                    }
                
                    if (!res.ok) {
                        const errorData = await res.json().catch(() => ({}));
                        console.error('Gemini API 错误:', res.status, errorData);
                        throw new Error(`API 错误 ${res.status}: ${errorData.error?.message || res.statusText}`);
                    }
                    data = await res.json();
                }
                const userLang = detectLanguage(text);
                const defaultReply = userLang === 'cn' 
                    ? '唔，我一时间有点想不到，等我再研究下先～'
                    : 'Well, I need to think about that for a moment...';
                const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || defaultReply;
                addChatMessage('agent', reply);
            } catch (e) {
                console.error('Gemini 调用失败:', e);
                const errorMsg = e.message || '未知错误';
                const userLang = detectLanguage(text);
                const errorMessage = userLang === 'cn'
                    ? `唔，AI 那边出问题了：${errorMsg}。请检查 API Key 是否正确，或者稍后再试。`
                    : `Oops, there's a problem with the AI: ${errorMsg}. Please check if your API Key is correct, or try again later.`;
                addChatMessage('agent', errorMessage);
            }
        }

        // 1. 初始化地图 [web:13]
        const map = L.map('map-background', { center: [22.3193, 114.1694], zoom: 13, zoomControl: false });
        // 地图样式配置
        const mapStyles = {
            dark: {
                nameCn: '深色',
                nameEn: 'Dark',
                url: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'
            },
            light: {
                nameCn: '浅色',
                nameEn: 'Light',
                url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png'
            },
            satellite: {
                nameCn: '卫星',
                nameEn: 'Satellite',
                url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
            },
            terrain: {
                nameCn: '地形',
                nameEn: 'Terrain',
                url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png'
            }
        };
        
        let currentMapStyle = 'dark';
        let currentTileLayer = L.tileLayer(mapStyles[currentMapStyle].url).addTo(map);
        const markerGroup = L.layerGroup().addTo(map);

        function updateMapStyleButton() {
            const btn = document.getElementById('map-style-toggle');
            if (!btn) return;
            const styleCfg = mapStyles[currentMapStyle];
            if (!styleCfg) return;
            const name = state.lang === 'cn' ? styleCfg.nameCn : styleCfg.nameEn;
            btn.innerHTML = `<svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true" style="width: 16px; height: 16px;"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"></path></svg> <span>${name}</span>`;
        }
        
        // 地图样式切换功能
        document.getElementById('map-style-toggle').onclick = () => {
            const styles = Object.keys(mapStyles);
            const currentIndex = styles.indexOf(currentMapStyle);
            const nextIndex = (currentIndex + 1) % styles.length;
            currentMapStyle = styles[nextIndex];
            
            // 移除旧图层
            map.removeLayer(currentTileLayer);
            
            // 添加新图层
            currentTileLayer = L.tileLayer(mapStyles[currentMapStyle].url).addTo(map);
            
            // 更新按钮文本（根据当前语言显示中/英文）
            updateMapStyleButton();
        };

        // 2. 数据加载与同步 [web:18]
        async function loadLocations() {
            try {
                const res = await fetch(`https://huggingface.co/datasets/${REPO_ID}/resolve/main/locations.json?t=${Date.now()}`);
                state.locations = await res.json();
                markerGroup.clearLayers();
                state.locations.forEach(loc => {
                    const ready = loc.status === 'ready';
                    L.circleMarker([loc.lat, loc.lon], { radius: 10, fillColor: ready ? '#00ff88' : '#ffcc00', fillOpacity: 0.8, color: '#fff', weight: 2 })
                    .addTo(markerGroup).on('click', () => {
                        state.currentLoc = loc;
                        state.currentLoc = loc;
                        // 根据当前语言渲染标题与描述
                        if (state.lang === 'cn') {
                            document.getElementById('loc-title').innerText = loc.name;
                            document.getElementById('loc-desc').innerText = loc.desc || "处理中...";
                        } else {
                            document.getElementById('loc-title').innerText = loc.name_en || loc.name;
                            document.getElementById('loc-desc').innerText = loc.desc_en || loc.desc || "Processing...";
                        }
                        document.getElementById('info-bar').style.display = 'block';
                        document.getElementById('enter-btn').disabled = !ready;
                        document.getElementById('enter-btn').style.opacity = ready ? "1" : "0.5";
                    });
                });
            } catch(e) { console.error("加载失败", e); }
        }

        // 设置 Splat 视觉效果
        function setupSplatModifier(splatMesh, effectType) {
            console.log('setupSplatModifier 调用，effectType:', effectType, 'animateT 存在:', !!state.animateT);
            // 确保 animateT 已初始化
            if (!state.animateT) {
                console.warn('animateT 未初始化，无法应用效果，尝试初始化');
                state.animateT = dyno.dynoFloat(0);
                if (!state.animateT) {
                    console.error('无法初始化 animateT');
                    return;
                }
            }
            
            // 如果选择"无效果"，但启用了心跳数据，仍然需要创建 modifier 来应用心跳波浪
            if (effectType === 'None') {
                // 如果没有心跳数据，且不在粒子显示模式，直接清除效果
                if ((!state.audiuno.usePhysiological || state.audiuno.lastHeartbeatTime <= 0) && !state.isParticleMode) {
                    splatMesh.objectModifier = null;
                    splatMesh.updateGenerator();
                    console.log('效果已清除');
                    return;
                }
                // 如果有心跳数据，继续创建 modifier 以应用心跳波浪效果
                console.log('无效果模式，但将应用心跳波浪效果');
            }

            // Reveal effects 使用 1-5，Shader effects 使用 10-14
            const revealEffectMap = {
                'Magic': 1,
                'Spread': 2,
                'Unroll': 3,
                'Twister': 4,
                'Rain': 5
            };
            
            const shaderEffectMap = {
                'Waves': 12,
                'Disintegrate': 14
            };
            
            const effectTypeMap = {
                'None': 0,
                ...revealEffectMap,
                ...shaderEffectMap
            };

            const effectInt = effectTypeMap[effectType] ?? (effectType === 'None' ? 0 : 1);

            splatMesh.objectModifier = dyno.dynoBlock(
                { gsplat: dyno.Gsplat },
                { gsplat: dyno.Gsplat },
                ({ gsplat }) => {
                    const d = new dyno.Dyno({
                        inTypes: { 
                            gsplat: dyno.Gsplat, 
                            t: "float", 
                            effectType: "int", 
                            intensity: "float", 
                            heartbeatTime: "float", 
                            heartbeatTime1: "float", 
                            heartbeatTime2: "float", 
                            heartbeatTime3: "float", 
                            particleMode: "int",
                            mouseX: "float",
                            mouseY: "float",
                            mouseZ: "float",
                            mouseTime: "float"
                        },
                        outTypes: { gsplat: dyno.Gsplat },
                        globals: () => [
                            dyno.unindent(`
                                vec3 hash(vec3 p) {
                                    return fract(sin(p*123.456)*123.456);
                                }

                                vec3 noise(vec3 p) {
                                    vec3 i = floor(p);
                                    vec3 f = fract(p);
                                    f = f * f * (3.0 - 2.0 * f);
                                    
                                    vec3 n000 = hash(i + vec3(0,0,0));
                                    vec3 n100 = hash(i + vec3(1,0,0));
                                    vec3 n010 = hash(i + vec3(0,1,0));
                                    vec3 n110 = hash(i + vec3(1,1,0));
                                    vec3 n001 = hash(i + vec3(0,0,1));
                                    vec3 n101 = hash(i + vec3(1,0,1));
                                    vec3 n011 = hash(i + vec3(0,1,1));
                                    vec3 n111 = hash(i + vec3(1,1,1));
                                    
                                    vec3 x0 = mix(n000, n100, f.x);
                                    vec3 x1 = mix(n010, n110, f.x);
                                    vec3 x2 = mix(n001, n101, f.x);
                                    vec3 x3 = mix(n011, n111, f.x);
                                    
                                    vec3 y0 = mix(x0, x1, f.y);
                                    vec3 y1 = mix(x2, x3, f.y);
                                    
                                    return mix(y0, y1, f.z);
                                }

                                mat2 rot(float a) {
                                    float s=sin(a),c=cos(a);
                                    return mat2(c,-s,s,c);
                                }

                                vec4 twister(vec3 pos, vec3 scale, float t) {
                                    vec3 h = hash(pos);
                                    float s = smoothstep(0., 8., t*t*.1 - length(pos.xz)*2.+2.);
                                    if (length(scale) < .05) pos.y = mix(-10., pos.y, pow(s, 2.*h.x));
                                    pos.xz = mix(pos.xz*.5, pos.xz, pow(s, 2.*h.x));
                                    float rotationTime = t * (1.0 - s) * 0.2;
                                    pos.xz *= rot(rotationTime + pos.y*20.*(1.-s)*exp(-1.*length(pos.xz)));
                                    return vec4(pos, s*s*s*s);
                                }

                                vec4 rain(vec3 pos, vec3 scale, float t) {
                                    vec3 h = hash(pos);
                                    float s = pow(smoothstep(0., 5., t*t*.1 - length(pos.xz)*2. + 1.), .5 + h.x);
                                    float y = pos.y;
                                    pos.y = min(-10. + s*15., pos.y);
                                    pos.xz = mix(pos.xz*.3, pos.xz, s);
                                    pos.xz *= rot(t*.3);
                                    return vec4(pos, smoothstep(-10., y, pos.y));
                                }

                                vec3 headMovement(vec3 pos, float t) {
                                    pos.xy *= rot(smoothstep(-1., -2., pos.y) * .2 * sin(t*2.));
                                    return pos;
                                }

                                vec3 breathAnimation(vec3 pos, float t) {
                                    float b = sin(t*1.5);
                                    pos.yz *= rot(smoothstep(-1., -3., pos.y) * .15 * -b);
                                    pos.z += .3;
                                    pos.y += 1.2;
                                    pos *= 1. + exp(-3. * length(pos)) * b;
                                    pos.z -= .3;
                                    pos.y -= 1.2;
                                    return pos;
                                }

                                vec4 fractal1(vec3 pos, float t, float intensity) {
                                    float m = 100.;
                                    vec3 p = pos * .1;
                                    p.y += .5;
                                    for (int i = 0; i < 8; i++) {
                                        p = abs(p) / clamp(abs(p.x * p.y), 0.3, 3.) - 1.;
                                        p.xy *= rot(radians(90.));
                                        if (i > 1) m = min(m, length(p.xy) + step(.3, fract(p.z * .5 + t * .5 + float(i) * .2)));
                                    }
                                    m = step(m, 0.5) * 1.3 * intensity;
                                    return vec4(-pos.y * .3, 0.5, 0.7, .3) * intensity + m;
                                }

                                vec4 fractal2(vec3 center, vec3 scales, vec4 rgba, float t, float intensity) {
                                    vec3 pos = center;
                                    float splatSize = length(scales);
                                    float pattern = exp(-50. * splatSize);
                                    vec3 p = pos * .65;
                                    pos.y += 2.;
                                    float c = 0.;
                                    float l, l2 = length(p);
                                    float m = 100.;
                                    
                                    for (int i = 0; i < 10; i++) {
                                        p.xyz = abs(p.xyz) / dot(p.xyz, p.xyz) - .8;
                                        l = length(p.xyz);
                                        c += exp(-1. * abs(l - l2) * (1. + sin(t * 1.5 + pos.y)));
                                        l2 = length(p.xyz);
                                        m = min(m, length(p.xyz));
                                    }
                                    
                                    c = smoothstep(0.3, 0.5, m + sin(t * 1.5 + pos.y * .5)) + c * .1;              
                                    return vec4(vec3(length(rgba.rgb)) * vec3(c, c*c, c*c*c) * intensity, 
                                              rgba.a * exp(-20. * splatSize) * m * intensity);
                                }

                                vec4 sin3D(vec3 p, float t) {
                                    float m = exp(-2. * length(sin(p * 5. + t * 3.))) * 5.;
                                    return vec4(m) + .3;
                                }

                                vec4 disintegrate(vec3 pos, float t, float intensity) {
                                    vec3 p = pos + (hash(pos) * 2. - 1.) * intensity;
                                    float tt = smoothstep(-1., 0.5, -sin(t + -pos.y * .5));  
                                    p.xz *= rot(tt * 2. + p.y * 2. * tt);
                                    return vec4(mix(p, pos, tt), tt);
                                }
                                
                                vec4 flare(vec3 pos, float t) {
                                    vec3 p = vec3(0., -1.5, 0.);
                                    float tt = smoothstep(-1., .5, sin(t + hash(pos).x));  
                                    tt = tt * tt;              
                                    p.x += sin(t * 2.) * tt;
                                    p.z += sin(t * 2.) * tt;
                                    p.y += sin(t) * tt;
                                    return vec4(mix(pos, p, tt), tt);
                                }

                                // 心跳波浪效果：从模型中心向外传播的波浪
                                vec3 heartbeatWave(vec3 pos, float t, float heartbeatTime) {
                                    if (heartbeatTime <= 0.0) return pos;
                                    
                                    // 计算从上次心跳到现在的时间
                                    float timeSinceBeat = t - heartbeatTime;
                                    
                                    // 波浪持续时间（约 1 秒）
                                    float waveDuration = 1.0;
                                    if (timeSinceBeat < 0.0 || timeSinceBeat > waveDuration) return pos;
                                    
                                    // 计算到模型中心的距离
                                    float dist = length(pos);
                                    
                                    // 计算波浪强度（距离波浪前沿越近，强度越大）
                                    float waveSpeed = 4.0;
                                    float waveFront = timeSinceBeat * waveSpeed;
                                    float waveDist = abs(dist - waveFront);
                                    float waveIntensity = exp(-waveDist * 2.5) * (1.0 - timeSinceBeat / waveDuration);
                                    
                                    // 应用径向起伏
                                    vec3 dir = normalize(pos);
                                    pos += dir * waveIntensity * 0.5;
                                    
                                    return pos;
                                }
                            `)
                        ],
                        statements: ({ inputs, outputs }) => dyno.unindentLines(`
                            ${outputs.gsplat} = ${inputs.gsplat};
                            
                            vec3 localPos = ${inputs.gsplat}.center;
                            vec3 splatScales = ${inputs.gsplat}.scales;
                            vec4 splatColor = ${inputs.gsplat}.rgba;
                            float t = ${inputs.t};
                            float heartbeatTime = ${inputs.heartbeatTime};
                            float heartbeatTime1 = ${inputs.heartbeatTime1};
                            float heartbeatTime2 = ${inputs.heartbeatTime2};
                            float heartbeatTime3 = ${inputs.heartbeatTime3};
                            float l = length(localPos.xz);
                            int effectType = int(${inputs.effectType});
                            int particleMode = int(${inputs.particleMode});
                            float mouseX = ${inputs.mouseX};
                            float mouseY = ${inputs.mouseY};
                            float mouseZ = ${inputs.mouseZ};
                            float mouseTime = ${inputs.mouseTime};

                            // 粒子显示模式：独立于任何效果（不是 Disintegrate，也不是 None）
                            // 目标：将高斯 splat 收缩成非常小的点状“粒子”，保留原色
                            if (particleMode == 1) {
                                // 鼠标轨迹扰动 + 发光：使用最近一次鼠标位置
                                // 注意：为保证效果明显，这里暂时不做时间衰减，只按空间距离衰减
                                if (mouseTime >= 0.0) {
                                    vec3 mousePos = vec3(mouseX, mouseY, mouseZ);
                                    float distToMouse = length(localPos - mousePos);
                                    // 距离越近扰动越强，使用指数衰减
                                    float spatialFalloff = exp(-distToMouse * 4.0);
                                    float mouseInfluence = spatialFalloff;
                                    
                                    // 位置扰动：沿从鼠标发出的径向方向轻微推动
                                    if (distToMouse > 0.0001) {
                                        vec3 dir = normalize(localPos - mousePos);
                                        localPos += dir * mouseInfluence * 0.35;
                                    }
                                    
                                    // 发光：提高亮度，偏蓝青色
                                    vec3 glowColor = vec3(0.4, 0.8, 1.2);
                                    splatColor.rgb = mix(splatColor.rgb, glowColor, mouseInfluence * 0.9);
                                    splatColor.a = clamp(splatColor.a + mouseInfluence * 0.8, 0.0, 1.0);
                                }

                                ${outputs.gsplat}.center = localPos;
                                // 不使用固定 world scale（会导致远处几乎不可见）
                                // 改为：按原始 splat 尺寸缩小，并设置最小尺寸，保证远处仍可见
                                float particleShrink = 0.12;
                                float particleMinScale = 0.0025;
                                ${outputs.gsplat}.scales = max(splatScales * particleShrink, vec3(particleMinScale));
                                ${outputs.gsplat}.rgba = splatColor;
                                ${outputs.gsplat}.rgba.a = max(${outputs.gsplat}.rgba.a, 0.8);
                            } else
                            
                            // 无效果模式（effectType == 0）：只在有心跳数据时应用类似 Magic 效果的径向展开
                            if (effectType == 0) {
                                // 使用最近一次心跳（heartbeatTime1 是最新的）
                                float activeBeat = heartbeatTime1 > 0.0 ? heartbeatTime1 : heartbeatTime;
                                if (activeBeat > 0.0) {
                                    // 计算从上次心跳到现在的时间
                                    float timeSinceBeat = t - activeBeat;
                                    float waveDuration = 2.0; // 心跳效果持续时间
                                    
                                    // 只在波浪持续时间内应用效果（每次心跳完整刷新）
                                    if (timeSinceBeat >= 0.0 && timeSinceBeat <= waveDuration) {
                                        // 使用类似 Magic 效果的径向展开逻辑
                                        // s: 从中心向外展开的半径，基于心跳时间
                                        // 心跳效果：从 0 开始，在 waveDuration 内展开到最大半径
                                        float maxRadius = 10.0;
                                        float s = smoothstep(0.0, waveDuration, timeSinceBeat) * maxRadius;
                                        
                                        // l: 粒子到中心的径向距离（XZ 平面）
                                        float l = length(localPos.xz);
                                        
                                        // border: 波浪前沿的距离
                                        float border = abs(s - l - 0.5);
                                        
                                        // 应用径向缩放（类似 Magic 效果）
                                        localPos *= 1.0 - 0.2 * exp(-20.0 * border);
                                        
                                        // 应用噪声效果（类似 Magic 效果）
                                        vec3 noiseOffset = noise(localPos.xyz * 2.0 + vec3(timeSinceBeat * 0.5)) * smoothstep(s - 0.5, s, l + 0.5);
                                        localPos += 0.1 * noiseOffset;
                                        
                                        // 应用粒子尺寸变化（类似 Magic 效果）
                                        vec3 finalScales = mix(splatScales, vec3(0.002), smoothstep(s - 0.5, s, l + 0.5));
                                        
                                        // 角度展开效果（类似 Magic 效果）
                                        float at = atan(localPos.x, localPos.z) / 3.1416;
                                        float angleReveal = step(at, timeSinceBeat - 3.1416);
                                        
                                        // 应用发光效果（类似 Magic 效果）
                                        float glow = exp(-20.0 * border) + exp(-50.0 * abs(timeSinceBeat - at - 3.1416)) * 0.5;
                                        
                                        // 使用 intensity 参数调整效果强度
                                        float effectIntensity = ${inputs.intensity};
                                        
                                        // 更新输出
                                        ${outputs.gsplat}.center = localPos;
                                        ${outputs.gsplat}.scales = mix(splatScales, finalScales, effectIntensity);
                                        ${outputs.gsplat}.rgba = splatColor * angleReveal + vec4(glow * effectIntensity, glow * effectIntensity, glow * effectIntensity, 0.0);
                                    } else {
                                        // 心跳效果结束后，恢复原始状态
                                        ${outputs.gsplat}.center = localPos;
                                        ${outputs.gsplat}.scales = splatScales;
                                        ${outputs.gsplat}.rgba = splatColor;
                                    }
                                } else {
                                    // 没有心跳数据时，保持原样
                                    ${outputs.gsplat}.center = localPos;
                                    ${outputs.gsplat}.scales = splatScales;
                                    ${outputs.gsplat}.rgba = splatColor;
                                }
                            }
                            // 应用心跳波浪效果（如果启用了生理信号且不是无效果模式）
                            else if (heartbeatTime > 0.0) {
                                localPos = heartbeatWave(localPos, t, heartbeatTime);
                            }
                            
                            if (effectType == 1) {
                                // Magic Effect: 更明显的径向展开效果
                                float s = smoothstep(0.,10.,t-4.5)*10.;
                                float border = abs(s-l-.5);
                                localPos *= 1.-.2*exp(-20.*border);
                                vec3 finalScales = mix(splatScales,vec3(0.002),smoothstep(s-.5,s,l+.5));
                                ${outputs.gsplat}.center = localPos + .1*noise(localPos.xyz*2.+vec3(t*.5))*smoothstep(s-.5,s,l+.5);
                                ${outputs.gsplat}.scales = finalScales;
                                float at = atan(localPos.x,localPos.z)/3.1416;
                                ${outputs.gsplat}.rgba *= step(at,t-3.1416);
                                float glow = exp(-20.*border) + exp(-50.*abs(t-at-3.1416))*.5;
                                ${outputs.gsplat}.rgba += vec4(glow, glow, glow, 0.0);
                                // 确保效果可见：如果时间太短，强制显示部分内容
                                if (t < 5.0) {
                                    ${outputs.gsplat}.rgba.a = max(${outputs.gsplat}.rgba.a, 0.3);
                                }
                                
                            } else if (effectType == 2) {
                                // Spread Effect: 更明显的扩散效果
                                float tt = t*t*.4+.5;
                                localPos.xz *= min(1.,.3+max(0.,tt*.05));
                                ${outputs.gsplat}.center = localPos;
                                ${outputs.gsplat}.scales = max(mix(vec3(0.0),splatScales,min(tt-7.-l*2.5,1.)),mix(vec3(0.0),splatScales*.2,min(tt-1.-l*2.,1.)));
                                ${outputs.gsplat}.rgba = mix(vec4(0.3, 0.3, 0.3, 1.0),splatColor,clamp(tt-l*2.5-3.,0.,1.));
                                
                            } else if (effectType == 3) {
                                // Unroll Effect: 更明显的展开效果
                                localPos.xz *= rot((localPos.y*50.-20.)*exp(-t));
                                ${outputs.gsplat}.center = localPos * (1.-exp(-t)*2.);
                                ${outputs.gsplat}.scales = mix(vec3(0.002),splatScales,smoothstep(.3,.7,t+localPos.y-2.));
                                ${outputs.gsplat}.rgba = splatColor*step(0.,t*.5+localPos.y-.5);
                            } else if (effectType == 4) {
                                // Twister Effect: 龙卷风效果
                                vec4 effectResult = twister(localPos, splatScales, t);
                                ${outputs.gsplat}.center = effectResult.xyz;
                                ${outputs.gsplat}.scales = mix(vec3(.002), splatScales, pow(effectResult.w, 12.));
                                float s = effectResult.w;
                                float spin = -t * 0.3 * (1.0 - s);
                                vec4 spinQ = vec4(0.0, sin(spin*0.5), 0.0, cos(spin*0.5));
                                ${outputs.gsplat}.quaternion = quatQuat(spinQ, ${inputs.gsplat}.quaternion);
                            } else if (effectType == 5) {
                                // Rain Effect: 雨效果
                                vec4 effectResult = rain(localPos, splatScales, t);
                                ${outputs.gsplat}.center = effectResult.xyz;
                                ${outputs.gsplat}.scales = mix(vec3(.005), splatScales, pow(effectResult.w, 30.));
                                float spin = -t*.3;
                                vec4 spinQ = vec4(0.0, sin(spin*0.5), 0.0, cos(spin*0.5));
                                ${outputs.gsplat}.quaternion = quatQuat(spinQ, ${inputs.gsplat}.quaternion);
                            }
                            // Shader effects (10-14)
                            else if (effectType == 12) {
                                // Waves Effect with heartbeat rhythm
                                // 计算心跳律动影响：叠加所有活跃的心跳效果，影响波的频率和相位
                                float frequencyMod = 0.0; // 频率调制
                                float phaseMod = 0.0; // 相位调制
                                
                                // 处理每个心跳（最多 3 个）
                                float[] beats = float[](heartbeatTime1, heartbeatTime2, heartbeatTime3);
                                for (int i = 0; i < 3; i++) {
                                    if (beats[i] > 0.0) {
                                        float timeSinceBeat = t - beats[i];
                                        float beatDuration = 2.0; // 每次心跳效果持续时间（更长，更平滑）
                                        if (timeSinceBeat >= 0.0 && timeSinceBeat <= beatDuration) {
                                            // 平滑过渡：使用 smoothstep 实现更平滑的衰减
                                            float normalizedTime = timeSinceBeat / beatDuration;
                                            float smoothPulse = (1.0 - smoothstep(0.0, 1.0, normalizedTime));
                                            
                                            // 每次心跳产生不同的峰值和相位偏移（基于心跳索引）
                                            float peakVariation = 0.3 + 0.7 * sin(float(i) * 2.094); // 0.3-1.0 之间变化
                                            float phaseOffset = float(i) * 1.047; // 每次心跳相位偏移不同
                                            
                                            // 频率调制：心跳时波速加快
                                            frequencyMod += smoothPulse * peakVariation * 0.8;
                                            // 相位调制：每次心跳产生不同的相位偏移
                                            phaseMod += smoothPulse * sin(phaseOffset) * 2.0;
                                        }
                                    }
                                }
                                // 限制叠加值
                                frequencyMod = min(frequencyMod, 1.2);
                                
                                // 将心跳律动应用到效果：影响波的频率和相位，而不是强度
                                // 心跳时频率增加，产生更快的波动
                                float modulatedT = t * (1.0 + frequencyMod * 0.6) + phaseMod;
                                vec4 effect = sin3D(localPos, modulatedT);
                                
                                // 保持原始 intensity，心跳只影响效果参数
                                ${outputs.gsplat}.rgba.rgba = mix(splatColor, splatColor*effect, ${inputs.intensity});
                                vec3 pos = localPos;
                                pos.y += 1.;
                                // 心跳律动影响位置变化（通过 effect 本身，而不是调整 intensity）
                                pos *= (1. + effect.x * .05 * ${inputs.intensity});
                                pos.y -= 1.;
                                ${outputs.gsplat}.center = pos;
                            } 
                            else if (effectType == 14) {
                                // Disintegrate Effect with heartbeat rhythm
                                // 计算心跳律动影响：叠加所有活跃的心跳效果，影响分解的速度和相位
                                float speedMod = 0.0; // 速度调制
                                float phaseMod = 0.0; // 相位调制
                                
                                float[] beats = float[](heartbeatTime1, heartbeatTime2, heartbeatTime3);
                                for (int i = 0; i < 3; i++) {
                                    if (beats[i] > 0.0) {
                                        float timeSinceBeat = t - beats[i];
                                        float beatDuration = 2.0; // 每次心跳效果持续时间（更长，更平滑）
                                        if (timeSinceBeat >= 0.0 && timeSinceBeat <= beatDuration) {
                                            // 平滑过渡：使用 smoothstep 实现更平滑的衰减
                                            float normalizedTime = timeSinceBeat / beatDuration;
                                            float smoothPulse = (1.0 - smoothstep(0.0, 1.0, normalizedTime));
                                            
                                            // 每次心跳产生不同的峰值和相位偏移（基于心跳索引）
                                            float peakVariation = 0.3 + 0.7 * sin(float(i) * 2.094); // 0.3-1.0 之间变化
                                            float phaseOffset = float(i) * 1.047; // 每次心跳相位偏移不同
                                            
                                            // 速度调制：心跳时分解速度加快
                                            speedMod += smoothPulse * peakVariation * 0.6;
                                            // 相位调制：每次心跳产生不同的相位偏移
                                            phaseMod += smoothPulse * sin(phaseOffset) * 1.5;
                                        }
                                    }
                                }
                                // 限制叠加值
                                speedMod = min(speedMod, 1.0);
                                
                                // 将心跳律动应用到效果：影响分解的速度和相位，而不是强度
                                // 心跳时分解速度增加，产生不同的峰值
                                float modulatedT = t * (1.0 + speedMod * 0.5) + phaseMod;
                                // 保持原始 intensity，心跳只影响效果参数（速度、相位）
                                vec4 e = disintegrate(localPos, modulatedT, ${inputs.intensity});
                                ${outputs.gsplat}.center = e.xyz;
                                ${outputs.gsplat}.scales = mix(vec3(.01, .01, .01), ${inputs.gsplat}.scales, e.w);
                            }
                        `),
                    });

                    // 确保 animateT 已初始化
                    if (!state.animateT) {
                        console.warn('animateT 未初始化，跳过效果');
                        return { gsplat };
                    }
                    
                    // 计算心跳时间数组（相对于 effectStartTime）
                    // 保留最近几次心跳，用于叠加效果
                    let heartbeatTimes = [];
                    if (state.audiuno.usePhysiological && state.audiuno.heartbeatTimes && state.audiuno.heartbeatTimes.length > 0) {
                        // 只保留最近 3 次心跳（用于叠加效果）
                        const recentBeats = state.audiuno.heartbeatTimes.slice(-3);
                        heartbeatTimes = recentBeats.map(beatTime => beatTime - state.effectStartTime).filter(t => t >= 0);
                    } else if (state.audiuno.usePhysiological && state.audiuno.lastHeartbeatTime > 0) {
                        // 如果没有历史记录，使用最近一次心跳
                        heartbeatTimes = [state.audiuno.lastHeartbeatTime - state.effectStartTime].filter(t => t >= 0);
                    }
                    
                    // 为了兼容性，也传递最近一次心跳时间
                    // heartbeatTimes 数组：最新的在最后，所以 heartbeatTime1 应该是最新的
                    let heartbeatTime = heartbeatTimes.length > 0 ? heartbeatTimes[heartbeatTimes.length - 1] : -1.0;
                    // 反转顺序，让 heartbeatTime1 是最新的心跳
                    let heartbeatTime1 = heartbeatTimes.length > 0 ? heartbeatTimes[heartbeatTimes.length - 1] : -1.0;
                    let heartbeatTime2 = heartbeatTimes.length > 1 ? heartbeatTimes[heartbeatTimes.length - 2] : -1.0;
                    let heartbeatTime3 = heartbeatTimes.length > 2 ? heartbeatTimes[heartbeatTimes.length - 3] : -1.0;
                    
                    console.log('心跳时间:', { heartbeatTime, heartbeatTime1, heartbeatTime2, heartbeatTime3, times: heartbeatTimes, length: heartbeatTimes.length });
                    
                    gsplat = d.apply({ 
                        gsplat, 
                        t: state.animateT,
                        effectType: dyno.dynoInt(effectInt),
                        intensity: dyno.dynoFloat(state.effectParams.intensity || 0.8),
                        heartbeatTime: dyno.dynoFloat(heartbeatTime),
                        heartbeatTime1: dyno.dynoFloat(heartbeatTime1),
                        heartbeatTime2: dyno.dynoFloat(heartbeatTime2),
                        heartbeatTime3: dyno.dynoFloat(heartbeatTime3),
                        particleMode: dyno.dynoInt(state.isParticleMode ? 1 : 0),
                        mouseX: dyno.dynoFloat(state.mouse ? state.mouse.worldX : 0),
                        mouseY: dyno.dynoFloat(state.mouse ? state.mouse.worldY : 0),
                        mouseZ: dyno.dynoFloat(state.mouse ? state.mouse.worldZ : 0),
                        mouseTime: dyno.dynoFloat(state.mouse ? state.mouse.lastTime : -1)
                    }).gsplat;
                    
                    return { gsplat };
                }
            );

            splatMesh.updateGenerator();
        }

        // 3. 核心 3D 渲染 - 使用 Spark 库
        // 清理 WebGL 资源的辅助函数
        function cleanupWebGL() {
            console.log('开始清理 WebGL 资源...');
            
            // 停止动画循环
            if (state.animationId) {
                cancelAnimationFrame(state.animationId);
                state.animationId = null;
            }
            
            // 清理场景中的对象
            if (state.scene) {
                while (state.scene.children.length > 0) {
                    const child = state.scene.children[0];
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                if (mat.map) mat.map.dispose();
                                mat.dispose();
                            });
                        } else {
                            if (child.material.map) child.material.map.dispose();
                            child.material.dispose();
                        }
                    }
                    state.scene.remove(child);
                }
                state.scene = null;
            }
            
            // 清理渲染器
            if (state.renderer) {
                const container = document.getElementById('splat-viewer');
                const canvas = state.renderer.domElement;
                
                // 安全地移除 canvas
                if (container && canvas && canvas.parentNode === container) {
                    try {
                        container.removeChild(canvas);
                    } catch (e) {
                        console.warn('移除 canvas 失败:', e);
                    }
                }
                
                // 强制清理 WebGL 上下文
                try {
                    if (state.renderer && typeof state.renderer.getContext === 'function') {
                        const gl = state.renderer.getContext();
                        if (gl && !gl.isContextLost()) {
                            const loseContext = gl.getExtension('WEBGL_lose_context');
                            if (loseContext) {
                                loseContext.loseContext();
                            }
                        }
                    }
                } catch (e) {
                    console.warn('清理 WebGL 上下文失败:', e);
                }
                
                // 释放渲染器资源
                try {
                    state.renderer.dispose();
                } catch (e) {
                    console.warn('释放渲染器失败:', e);
                }
                
                state.renderer = null;
            }
            
            // 清理控制器
            if (state.controls) {
                try {
                    if (typeof state.controls.dispose === 'function') {
                        state.controls.dispose();
                    }
                } catch (e) {
                    console.warn('清理控制器失败:', e);
                }
                state.controls = null;
            }
            
            // 清理其他资源
            state.splatMesh = null;
            state.camera = null;
            state.animateT = null;
            
            console.log('WebGL 资源清理完成');
        }

        document.getElementById('enter-btn').onclick = async () => {
            // 防止重复点击
            if (state.isInitializing) {
                console.log('正在初始化中，请稍候...');
                return;
            }
            
            const container = document.getElementById('splat-viewer');
            const loader = document.getElementById('loading-overlay');
            
            // 设置初始化标志
            state.isInitializing = true;
            
            try {
            container.style.display = 'block';
                loader.style.display = 'flex';
                loader.innerText = '正在初始化...';

                // 打开 3D 视图时隐藏地图和上层 UI，避免挡住模型交互
                document.getElementById('ui-layer').style.display = 'none';
                document.getElementById('map-background').style.display = 'none';
                // 确保任务弹窗关闭，避免灰色蒙层残留
                const modal = document.getElementById('modal-overlay');
                if (modal) modal.style.display = 'none';
                // 显示聊天窗口（由 showChatUI 控制内部内容）
                showChatUI();
                
                // 显示效果控制面板
                const effectControls = document.getElementById('effect-controls');
                if (effectControls) {
                    effectControls.style.display = 'block';
                    // 设置当前选择的效果
                    const effectSelect = document.getElementById('effect-select');
                    if (effectSelect) {
                        effectSelect.value = state.effectParams.effect;
                    }
                    // 显示/隐藏强度控制（仅 shader effects 需要）
                    const intensityControl = document.getElementById('intensity-control');
                    const shaderEffects = ['Waves', 'Disintegrate'];
                    const isShaderEffect = shaderEffects.includes(state.effectParams.effect);
                    if (intensityControl) {
                        intensityControl.style.display = isShaderEffect ? 'block' : 'none';
                    }
                    // 设置强度滑块的值
                    const intensitySlider = document.getElementById('intensity-slider');
                    const intensityValue = document.getElementById('intensity-value');
                    if (intensitySlider && intensityValue) {
                        intensitySlider.value = state.effectParams.intensity || 0.8;
                        intensityValue.textContent = (state.effectParams.intensity || 0.8).toFixed(2);
                    }
                }
                
                // 显示语言切换按钮
                const viewLangToggle = document.getElementById('view-lang-toggle');
                if (viewLangToggle) {
                    viewLangToggle.style.display = 'block';
                    viewLangToggle.innerText = state.lang === 'cn' ? 'EN / 中' : '中 / EN';
                }

                // 清理之前的场景（使用改进的清理函数）
                cleanupWebGL();
                
                // 等待一小段时间，确保清理完成
                await new Promise(resolve => setTimeout(resolve, 100));

                // 创建场景
                state.scene = new THREE.Scene();
                state.scene.background = new THREE.Color(0x1a1a1a);

                // 创建相机
                state.camera = new THREE.PerspectiveCamera(
                    60,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                state.camera.position.set(0, 0, 5);

                // 创建渲染器（添加错误处理和降级支持）
                let rendererOptions = { 
                    antialias: true,
                    powerPreference: "high-performance",
                    failIfMajorPerformanceCaveat: false
                };
                
                try {
                    state.renderer = new THREE.WebGLRenderer(rendererOptions);
                } catch (e) {
                    console.warn('WebGL2 创建失败，尝试 WebGL1:', e);
                    // 如果 WebGL2 失败，尝试 WebGL1
                    rendererOptions = { 
                        antialias: false,
                        powerPreference: "default"
                    };
                    try {
                        state.renderer = new THREE.WebGLRenderer(rendererOptions);
                    } catch (e2) {
                        throw new Error('无法创建 WebGL 上下文。请检查浏览器和显卡驱动是否支持 WebGL。');
                    }
                }
                
                // 检查渲染器是否成功创建
                if (!state.renderer || !state.renderer.getContext()) {
                    throw new Error('WebGL 上下文创建失败');
                }
                state.renderer.setSize(window.innerWidth, window.innerHeight);
                state.renderer.setPixelRatio(window.devicePixelRatio);
                state.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                state.renderer.toneMappingExposure = 1.2;
                container.appendChild(state.renderer.domElement);

                // 创建控制器（使用 SparkControls）
                state.controls = new SparkControls({ canvas: state.renderer.domElement });

                // 注册 3D viewer 鼠标移动，用于粒子模式的“鼠标轨迹扰动 + 发光”
                const viewerCanvas = state.renderer.domElement;
                const raycaster = new THREE.Raycaster();
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // y=0 平面
                const mouseNDC = new THREE.Vector2();

                function onViewerPointerMove(e) {
                    if (!state.camera) return;
                    const rect = viewerCanvas.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                    mouseNDC.set(x, y);
                    raycaster.setFromCamera(mouseNDC, state.camera);
                    const worldPos = new THREE.Vector3();
                    if (raycaster.ray.intersectPlane(plane, worldPos)) {
                        state.mouse.worldX = worldPos.x;
                        state.mouse.worldY = worldPos.y;
                        state.mouse.worldZ = worldPos.z;
                        // 使用 effectTime 时间轴：baseTime 相当于当前全局动画时间
                        state.mouse.lastTime = state.baseTime;
                    }
                }
                viewerCanvas.addEventListener('pointermove', onViewerPointerMove);

                // 加载 splat 模型
                const url = `https://huggingface.co/datasets/${REPO_ID}/resolve/main/${state.currentLoc.splatPath}`;
                loader.innerText = '📦 正在解析模型文件...';
                
                // 创建 SplatMesh
                state.splatMesh = new SplatMesh({ url: url });
                
                // 添加到场景
                state.scene.add(state.splatMesh);
                
                // 等待模型加载完成
                loader.innerText = '等待模型加载...';
                await state.splatMesh.loaded;
                loader.innerText = '模型加载完成！';
                
                // 初始化动画时间（必须在模型加载后）
                state.animateT = dyno.dynoFloat(0);
                state.baseTime = 0;
                state.effectStartTime = 0; // 效果开始时间，用于重置效果
                
                // 设置视觉效果（必须在 animateT 初始化后）
                console.log('设置视觉效果，effectType:', state.effectParams.effect, 'animateT:', state.animateT);
                setupSplatModifier(state.splatMesh, state.effectParams.effect);
                console.log('视觉效果设置完成');
                
                // 居中模型并修复倒置问题
                console.log('开始居中模型...');
                
                // 先修复上下颠倒：绕X轴旋转180度
                state.splatMesh.rotation.x = Math.PI;
                
                // 计算边界框（考虑旋转后）
                const box = new THREE.Box3().setFromObject(state.splatMesh);
                console.log('模型边界框:', box.min, box.max);
                
                if (box.isEmpty()) {
                    console.warn('边界框为空，使用默认位置');
                    state.modelCenter = new THREE.Vector3(0, 0, 0);
                    state.camera.position.set(0, 0, 5);
                    state.camera.lookAt(state.modelCenter);
                } else {
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    console.log('模型中心:', center, '尺寸:', size);
                    
                    // 将模型移动到原点（居中）
                    state.splatMesh.position.sub(center);
                    
                    // 保存模型中心点（用于相机看向和旋转）
                    state.modelCenter = new THREE.Vector3(0, 0, 0);
                    
                    // 重新计算边界框确认居中
                    const box2 = new THREE.Box3().setFromObject(state.splatMesh);
                    const center2 = box2.getCenter(new THREE.Vector3());
                    console.log('居中后的中心:', center2);
                    
                    // 调整相机位置，确保模型在视野中心
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const cameraDistance = maxDim * 2.5;
                    state.camera.position.set(0, 0, cameraDistance);
                    state.camera.lookAt(state.modelCenter);
                    console.log('相机位置:', state.camera.position, '距离:', cameraDistance);
                }
                
                // 隐藏加载提示
                loader.style.display = 'none';
                loader.style.pointerEvents = 'none';

                // 确保场景中有内容
                console.log('场景对象数量:', state.scene.children.length);
                console.log('SplatMesh:', state.splatMesh);
                console.log('相机位置:', state.camera.position);
                console.log('相机朝向:', state.camera.rotation);

                // 渲染循环
                state.lastTime = performance.now();
                function animate() {
                    const currentTime = performance.now();
                    const deltaTime = (currentTime - state.lastTime) / 1000; // 转换为秒
                    state.lastTime = currentTime;
                    state.baseTime += deltaTime;
                    
                    // 如果使用生理信号，预测心跳事件
                    if (state.audiuno.usePhysiological) {
                        predictHeartbeat();
                    }
                    
                    if (state.animateT) {
                        // 使用相对于效果开始时间的时间
                        let effectTime = state.baseTime - state.effectStartTime;
                        
                        // 如果使用生理信号，根据心率调整动画速度
                        if (state.audiuno.usePhysiological && state.audiuno.heartRate > 0) {
                            // 心率映射到速度倍数：60 BPM -> 0.8x, 100 BPM -> 1.2x
                            const speedMultiplier = 0.8 + ((state.audiuno.heartRate - 60) / 40) * 0.4;
                            effectTime *= speedMultiplier;
                        }
                        
                        state.animateT.value = effectTime;
                    }
                    
                    // 更新 splat 渲染
                    if (state.splatMesh) {
                        state.splatMesh.updateVersion();
                    }
                    
                    // 更新控制器和渲染
                    if (state.controls && state.camera) {
                        state.controls.update(state.camera);
                    }
                    if (state.renderer && state.scene && state.camera) {
                        state.renderer.render(state.scene, state.camera);
                    }
                    
                    state.animationId = requestAnimationFrame(animate);
                }
                animate();

                // 处理窗口大小变化
                const handleResize = () => {
                    if (state.camera && state.renderer) {
                        state.camera.aspect = window.innerWidth / window.innerHeight;
                        state.camera.updateProjectionMatrix();
                        state.renderer.setSize(window.innerWidth, window.innerHeight);
                    }
                };
                window.addEventListener('resize', handleResize);
                state.resizeHandler = handleResize; // 保存引用以便清理
                
                // 隐藏加载提示
                loader.style.display = 'none';
                
                // 初始化完成，重置标志
                state.isInitializing = false;

                // 注册 viewer 键盘监听：F 键切换粒子形态
                state.viewerKeyHandler = (e) => {
                    // 确保聊天输入框不会触发 viewer 快捷键
                    if (e.target && (e.target.id === 'chat-input' || e.target.closest && e.target.closest('#chat-window'))) {
                        return;
                    }
                    if (e.key === 'f' || e.key === 'F') {
                        e.preventDefault();
                        e.stopPropagation();
                        toggleParticleMode();
                    }
                };
                document.addEventListener('keydown', state.viewerKeyHandler, true);

            } catch (err) {
                console.error('加载模型失败:', err);
                loader.innerText = '❌ 加载失败: ' + (err.message || '请检查模型文件');
                loader.style.display = 'flex';
                setTimeout(() => {
                    loader.style.display = 'none';
                }, 3000);
                
                // 清理已创建的资源
                cleanupWebGL();
                
                // 初始化失败，重置标志
                state.isInitializing = false;
            }
        };

        // 4. 物理删除逻辑 [web:31][web:79][web:83]
        document.getElementById('del-btn').onclick = async () => {
            const token = prompt("请输入 HF Write Token 以确认删除：");
            if (!token || !confirm("永久删除该模型及照片？")) return;

            const operations = [
                { operation: "delete", path: state.currentLoc.photoPath },
                { operation: "addOrUpdate", path: "locations.json", content: new Blob([JSON.stringify(state.locations.filter(l => l.id !== state.currentLoc.id), null, 2)], {type:"application/json"}) }
            ];
            if (state.currentLoc.splatPath) operations.push({ operation: "delete", path: state.currentLoc.splatPath });

            try {
                await commit({ credentials: { accessToken: token }, repo: { type: "dataset", name: REPO_ID }, title: "Delete location", operations });
                location.reload();
            } catch (e) { alert("删除失败，请检查权限。"); }
        };

        // 自动翻译：当输入中文描述时，自动翻译为英文（保存到 state 中）
        let autoTranslatedDescEn = '';
        document.getElementById('desc-input').addEventListener('input', async (e) => {
            const descCn = e.target.value.trim();
            if (descCn && state.deeplKey) {
                autoTranslatedDescEn = await translateWithDeepL(descCn);
                console.log('✅ 描述已自动翻译为英文');
            } else {
                autoTranslatedDescEn = '';
            }
        });
        
        // 自动翻译：当输入中文名称时，自动翻译为英文
        document.getElementById('loc-name').addEventListener('input', async (e) => {
            const nameCn = e.target.value.trim();
            const nameEnInput = document.getElementById('loc-name-en');
            if (nameCn && state.deeplKey && !nameEnInput.value.trim()) {
                nameEnInput.placeholder = '正在翻译...';
                const translated = await translateWithDeepL(nameCn);
                nameEnInput.value = translated;
                nameEnInput.placeholder = 'Location Name (English，留空将自动翻译)';
            }
        });
        
        // 5. 上传任务逻辑
        document.getElementById('submit-btn').onclick = async () => {
            const token = document.getElementById('hf-token').value.trim();
            const file = document.getElementById('photo-input').files[0];
            const name = document.getElementById('loc-name').value.trim();
            let nameEn = document.getElementById('loc-name-en').value.trim();
            const desc = document.getElementById('desc-input').value.trim();
            
            if (!token || !file || !state.selectedCoords || !name) {
                alert("请填写完整信息：Token、照片、坐标和中文名称");
                return;
            }
            
            // 如果没有英文名称，尝试翻译
            if (!nameEn && state.deeplKey) {
                nameEn = await translateWithDeepL(name);
            }
            if (!nameEn) nameEn = name;
            
            // 获取自动翻译的英文描述，如果没有则翻译
            let descEn = autoTranslatedDescEn;
            if (!descEn && desc && state.deeplKey) {
                descEn = await translateWithDeepL(desc);
            }
            if (!descEn) descEn = desc || "";

            const ts = Date.now();
            const safeName = file.name.replace(/[^a-z0-9.]/gi, '_');
            const photoPath = `inputs/${ts}_${safeName}`;
            
            const newLoc = {
                id: ts,
                lat: state.selectedCoords.lat,
                lon: state.selectedCoords.lng,
                name: name,
                name_en: nameEn,
                desc: desc || "",
                desc_en: descEn,
                photoPath: photoPath,
                splatPath: "",
                status: "processing"
            };
            
            const newLocations = [...state.locations, newLoc];

            try {
                await commit({
                    credentials: { accessToken: token },
                    repo: { type: "dataset", name: REPO_ID },
                    title: `Upload task ${ts}`,
                    operations: [
                        { operation: "addOrUpdate", path: photoPath, content: file },
                        { operation: "addOrUpdate", path: "locations.json", content: new Blob([JSON.stringify(newLocations, null, 2)], {type:"application/json"}) }
                    ]
                });
                alert("任务上传成功！");
                document.getElementById('modal-overlay').style.display = 'none';
                // 清空表单（保留 DeepL Key）
                document.getElementById('hf-token').value = '';
                document.getElementById('loc-name').value = '';
                document.getElementById('loc-name-en').value = '';
                document.getElementById('lat-lon').value = '';
                document.getElementById('photo-input').value = '';
                document.getElementById('desc-input').value = '';
                autoTranslatedDescEn = '';
                state.selectedCoords = null;
                loadLocations();
            } catch (e) {
                alert("上传失败：" + (e.message || e));
            }
        };

        // 6. 其他交互逻辑 (拾取、上传、AI)
        document.getElementById('upload-btn').onclick = () => document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('pick-btn').onclick = () => { document.getElementById('modal-overlay').style.display = 'none'; state.isPicking = true; };
        map.on('click', (e) => {
            if (state.isPicking) {
                state.selectedCoords = e.latlng;
                document.getElementById('lat-lon').value = `${e.latlng.lat.toFixed(4)}, ${e.latlng.lng.toFixed(4)}`;
                state.isPicking = false;
                document.getElementById('modal-overlay').style.display = 'flex';
            }
        });

        document.getElementById('close-splat').onclick = () => {
            document.getElementById('splat-viewer').style.display = 'none';
            // 切换/退出场景时清空对话记忆
            clearChatMemory();
            state.chatSceneKey = null;
            const chatWin = document.getElementById('chat-window');
            if (chatWin) chatWin.style.display = 'none';
            state.isChatOpen = false;
            // 关闭 3D 视图时恢复地图和 UI
            document.getElementById('ui-layer').style.display = 'block';
            document.getElementById('map-background').style.display = 'block';
            // 隐藏效果控制面板和旋转按钮
            const effectControls = document.getElementById('effect-controls');
            if (effectControls) {
                effectControls.style.display = 'none';
            }
            // 清理资源
            if (state.renderer) {
                state.renderer.setAnimationLoop(null);
            }
            if (state.animationId) {
                cancelAnimationFrame(state.animationId);
                state.animationId = null;
            }
            state.lastTime = undefined;
            if (state.resizeHandler) {
                window.removeEventListener('resize', state.resizeHandler);
                state.resizeHandler = null;
            }
            if (state.controls) {
                state.controls.dispose();
                state.controls = null;
            }
            if (state.renderer) {
                const container = document.getElementById('splat-viewer');
                if (state.renderer.domElement && container.contains(state.renderer.domElement)) {
                    container.removeChild(state.renderer.domElement);
                }
                state.renderer.dispose();
                state.renderer = null;
            }
            if (state.splatMesh) {
                if (state.scene) {
                    state.scene.remove(state.splatMesh);
                }
                // 如果 SplatMesh 有 dispose 方法，调用它
                if (state.splatMesh.dispose) {
                    state.splatMesh.dispose();
                }
                state.splatMesh = null;
            }
            if (state.scene) {
                state.scene.clear();
                state.scene = null;
            }
            state.camera = null;

            // 移除 viewer 键盘监听
            if (state.viewerKeyHandler) {
                document.removeEventListener('keydown', state.viewerKeyHandler, true);
                state.viewerKeyHandler = null;
            }
            state.isParticleMode = false;
            state.prevEffectForParticle = null;
            // 重置鼠标轨迹状态
            if (state.mouse) {
                state.mouse.worldX = 0;
                state.mouse.worldY = 0;
                state.mouse.worldZ = 0;
                state.mouse.lastTime = -1;
            }
        };

        document.getElementById('save-key-btn').onclick = () => {
            const key = document.getElementById('user-gemini-key').value.trim();
            if (key) {
                ACTIVE_GEMINI_KEY = key;
                localStorage.setItem('MY_GEMINI_KEY', key);
                document.getElementById('gemini-config-ui').style.display = 'none';
                document.getElementById('chat-main-ui').style.display = 'flex';
                // 根据当前语言设置欢迎消息
                if (state.lang === 'cn') {
                    addChatMessage('agent', '好呀，我已经连上 Gemini 了，随便问我关于这个场景的任何问题～');
                } else {
                    addChatMessage('agent', 'Great! I\'ve connected to Gemini. Feel free to ask me anything about this scene!');
                }
            }
        };

        // 聊天发送按钮和回车键
        document.getElementById('chat-send').onclick = () => { handleChat(); };
        
        // 获取聊天输入框
        const chatInput = document.getElementById('chat-input');
        
        // 处理键盘事件：阻止与 3D viewer 快捷键冲突
        chatInput.addEventListener('keydown', (e) => {
            // 阻止事件冒泡，防止触发 3D viewer 的快捷键
            e.stopPropagation();
            
            if (e.key === 'Enter') {
                e.preventDefault();
                handleChat();
            }
        });
        
        // 处理键盘事件：阻止所有键盘事件冒泡
        chatInput.addEventListener('keyup', (e) => {
            e.stopPropagation();
        });
        
        // 处理输入事件：阻止输入事件冒泡
        chatInput.addEventListener('input', (e) => {
            e.stopPropagation();
        });
        
        // 当输入框获得焦点时，禁用 3D viewer 的控制器
        chatInput.addEventListener('focus', () => {
            if (state.controls) {
                // 临时禁用控制器（如果支持）
                if (typeof state.controls.enabled !== 'undefined') {
                    state.controls.enabled = false;
                }
            }
            // 阻止所有键盘事件传播到 document
            document.addEventListener('keydown', preventViewerShortcuts, true);
            document.addEventListener('keyup', preventViewerShortcuts, true);
        });
        
        // 当输入框失去焦点时，重新启用 3D viewer 的控制器
        chatInput.addEventListener('blur', () => {
            if (state.controls) {
                // 重新启用控制器
                if (typeof state.controls.enabled !== 'undefined') {
                    state.controls.enabled = true;
                }
            }
            // 移除事件监听器
            document.removeEventListener('keydown', preventViewerShortcuts, true);
            document.removeEventListener('keyup', preventViewerShortcuts, true);
        });
        
        // 阻止 3D viewer 快捷键的函数
        function preventViewerShortcuts(e) {
            // 如果事件来自聊天输入框或其父元素，阻止传播
            const target = e.target;
            if (target && (target.id === 'chat-input' || target.closest('#chat-window'))) {
                e.stopPropagation();
            }
        }

        // 语言切换按钮
        document.getElementById('lang-toggle').onclick = () => {
            state.lang = state.lang === 'cn' ? 'en' : 'cn';
            updateLangUI();
        };

        // 效果选择器
        document.getElementById('effect-select').addEventListener('change', (e) => {
            const effect = e.target.value;
            state.effectParams.effect = effect;
            console.log('切换视觉效果:', effect);
            
            // 显示/隐藏强度控制（仅 shader effects 需要）
            const intensityControl = document.getElementById('intensity-control');
            const shaderEffects = ['Waves', 'Disintegrate'];
            const isShaderEffect = shaderEffects.includes(effect);
            if (intensityControl) {
                intensityControl.style.display = isShaderEffect ? 'block' : 'none';
            }
            
            if (state.splatMesh) {
                // 确保 animateT 已初始化
                if (!state.animateT) {
                    console.warn('切换效果时 animateT 未初始化，重新初始化');
                    state.animateT = dyno.dynoFloat(0);
                }
                // 重置效果开始时间，让效果重新开始
                state.effectStartTime = state.baseTime;
                setupSplatModifier(state.splatMesh, effect);
                // 强制更新渲染
                if (state.splatMesh.updateVersion) {
                    state.splatMesh.updateVersion();
                }
            } else {
                console.warn('切换效果时 splatMesh 不存在');
            }
        });

        // F 键切换粒子形态（在 3D viewer 中）
        // 需求：按 F 切换到“粒子显示状态”（强制点状显示），不属于任何一种 effect，也不改下拉框
        function toggleParticleMode() {
            if (!state.splatMesh) return;

            if (!state.isParticleMode) {
                state.isParticleMode = true;
                setupSplatModifier(state.splatMesh, state.effectParams.effect);
                if (state.splatMesh.updateVersion) state.splatMesh.updateVersion();
                console.log('粒子形态：开启（粒子显示状态）');
            } else {
                state.isParticleMode = false;
                setupSplatModifier(state.splatMesh, state.effectParams.effect);
                if (state.splatMesh.updateVersion) state.splatMesh.updateVersion();
                console.log('粒子形态：关闭（恢复原渲染）');
            }
        }

        // 强度滑块控制
        const intensitySlider = document.getElementById('intensity-slider');
        const intensityValue = document.getElementById('intensity-value');
        if (intensitySlider && intensityValue) {
            intensitySlider.addEventListener('input', (e) => {
                state.effectParams.intensity = parseFloat(e.target.value);
                intensityValue.textContent = state.effectParams.intensity.toFixed(2);
                if (state.splatMesh && state.effectParams.effect !== 'None') {
                    setupSplatModifier(state.splatMesh, state.effectParams.effect);
                    if (state.splatMesh.updateVersion) {
                        state.splatMesh.updateVersion();
                    }
                }
            });
        }

        // 时间重置按钮
        document.getElementById('reset-time-btn').addEventListener('click', () => {
            if (state.splatMesh && state.effectParams.effect !== 'None') {
                // 重置效果开始时间，让效果重新开始
                state.effectStartTime = state.baseTime;
                console.log('效果时间已重置，当前 baseTime:', state.baseTime);
            }
        });

        // 3D视图语言切换按钮
        document.getElementById('view-lang-toggle').addEventListener('click', () => {
            state.lang = state.lang === 'cn' ? 'en' : 'cn';
            updateLangUI();
            // 更新按钮文本
            const viewLangToggle = document.getElementById('view-lang-toggle');
            if (viewLangToggle) {
                viewLangToggle.innerText = state.lang === 'cn' ? 'EN / 中' : '中 / EN';
            }
            // 更新效果选择器的标签
            const effectLabel = document.querySelector('#effect-controls label');
            if (effectLabel) {
                effectLabel.innerText = state.lang === 'cn' ? '视觉效果：' : 'Visual Effects:';
            }
            // 更新效果选项文本
            const effectSelect = document.getElementById('effect-select');
            if (effectSelect) {
                const options = effectSelect.options;
                if (state.lang === 'cn') {
                    // Reveal effects
                    options[0].text = '无效果';
                    options[1].text = '魔法';
                    options[2].text = '扩散';
                    options[3].text = '展开';
                    options[4].text = '龙卷风';
                    options[5].text = '雨';
                    // Shader effects
                    if (options.length > 6) {
                        options[6].text = '波浪';
                        options[7].text = '分解';
                    }
                } else {
                    // Reveal effects
                    options[0].text = 'None';
                    options[1].text = 'Magic';
                    options[2].text = 'Spread';
                    options[3].text = 'Unroll';
                    options[4].text = 'Twister';
                    options[5].text = 'Rain';
                    // Shader effects
                    if (options.length > 6) {
                        options[6].text = 'Waves';
                        options[7].text = 'Disintegrate';
                    }
                }
            }
            // 更新返回按钮文本
            const closeSplat = document.getElementById('close-splat');
            if (closeSplat) {
                const span = closeSplat.querySelector('span');
                if (span) span.textContent = state.lang === 'cn' ? '返回地图' : 'Back to Map';
            }
        });

        // ===== Audiuno 生理信号连接 =====
        async function connectAudiuno() {
            if (!('serial' in navigator)) {
                alert('您的浏览器不支持 Web Serial API。请使用 Chrome、Edge 或 Opera 浏览器。');
                return;
            }

            try {
                // 请求串口连接
                const port = await navigator.serial.requestPort();
                await port.open({ baudRate: 9600 }); // 根据 audiuno 的波特率调整

                state.audiuno.port = port;
                state.audiuno.isConnected = true;
                // 是否接受心跳数据由 UI 开关决定

                // 更新 UI
                document.getElementById('audiuno-status').textContent = state.lang === 'cn' ? '已连接' : 'Connected';
                const connectBtn = document.getElementById('connect-audiuno-btn');
                if (connectBtn) {
                    const span = connectBtn.querySelector('span');
                    if (span) span.textContent = state.lang === 'cn' ? '断开连接' : 'Disconnect';
                }
                document.getElementById('heart-rate-display').style.display = 'block';
                const hbToggle = document.getElementById('use-heartbeat-toggle');
                if (hbToggle) state.audiuno.usePhysiological = !!hbToggle.checked;

                // 开始读取数据
                readAudiunoData();

            } catch (err) {
                console.error('连接 Audiuno 失败:', err);
                if (err.name !== 'NotFoundError') {
                    alert('连接失败: ' + err.message);
                }
            }
        }

        async function disconnectAudiuno() {
            if (state.audiuno.reader) {
                await state.audiuno.reader.cancel();
                state.audiuno.reader = null;
            }
            if (state.audiuno.port) {
                await state.audiuno.port.close();
                state.audiuno.port = null;
            }
            state.audiuno.isConnected = false;
            state.audiuno.heartRate = 0;
            state.audiuno.lastHeartbeatTime = 0;

            // 更新 UI
            document.getElementById('audiuno-status').textContent = state.lang === 'cn' ? '未连接' : 'Disconnected';
                const connectBtn = document.getElementById('connect-audiuno-btn');
                if (connectBtn) {
                    const span = connectBtn.querySelector('span');
                    if (span) span.textContent = state.lang === 'cn' ? '连接 Audiuno' : 'Connect Audiuno';
                }
            document.getElementById('heart-rate-display').style.display = 'none';
            document.getElementById('heart-rate-value').textContent = '--';
        }

        async function readAudiunoData() {
            const decoder = new TextDecoder();
            let buffer = '';

            try {
                const reader = state.audiuno.port.readable.getReader();
                state.audiuno.reader = reader;

                while (state.audiuno.isConnected) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    
                    // 解析数据（假设格式为 "HR:75\n" 或 JSON 格式）
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || ''; // 保留不完整的行

                    for (const line of lines) {
                        if (line.trim()) {
                            parsePhysiologicalData(line.trim());
                        }
                    }
                }
            } catch (err) {
                console.error('读取数据失败:', err);
                if (state.audiuno.isConnected) {
                    await disconnectAudiuno();
                }
            }
        }

        function parsePhysiologicalData(data) {
            // 解析多种可能的数据格式
            // 格式1: "HR:75" 或 "heartRate:75"
            const hrMatch = data.match(/(?:HR|heartRate|心率)[:\s]+(\d+)/i);
            if (hrMatch) {
                const hr = parseInt(hrMatch[1]);
                if (hr > 0 && hr < 250) {
                    updateHeartRate(hr);
                }
                return;
            }

            // 格式2: JSON 格式 {"heartRate": 75, "bpm": 75}
            try {
                const json = JSON.parse(data);
                if (json.heartRate || json.bpm || json.hr) {
                    const hr = json.heartRate || json.bpm || json.hr;
                    if (hr > 0 && hr < 250) {
                        updateHeartRate(hr);
                    }
                }
            } catch (e) {
                // 不是 JSON，尝试其他格式
            }

            // 格式3: 纯数字（假设是心率）
            const numMatch = data.match(/^\d+$/);
            if (numMatch) {
                const hr = parseInt(numMatch[0]);
                if (hr > 40 && hr < 200) {
                    updateHeartRate(hr);
                }
            }
        }

        function updateHeartRate(hr) {
            const previousHR = state.audiuno.heartRate;
            state.audiuno.heartRate = hr;
            document.getElementById('heart-rate-value').textContent = hr;

            // 检测心跳事件：当心率值变化时，记录心跳时间
            // 或者可以通过心率间隔来预测下一次心跳
            if (state.audiuno.usePhysiological && previousHR > 0 && hr !== previousHR) {
                // 记录心跳时间（相对于 baseTime）
                state.audiuno.lastHeartbeatTime = state.baseTime;
                // 添加到心跳历史记录（保留最近 5 次）
                if (!state.audiuno.heartbeatTimes) {
                    state.audiuno.heartbeatTimes = [];
                }
                state.audiuno.heartbeatTimes.push(state.baseTime);
                // 只保留最近 5 次心跳
                if (state.audiuno.heartbeatTimes.length > 5) {
                    state.audiuno.heartbeatTimes.shift();
                }
                console.log('💓 心跳检测:', hr, 'BPM, 时间:', state.audiuno.lastHeartbeatTime, '历史记录:', state.audiuno.heartbeatTimes.length);
            } else if (state.audiuno.usePhysiological && previousHR === 0 && hr > 0) {
                // 首次收到心率数据，初始化心跳时间
                state.audiuno.lastHeartbeatTime = state.baseTime;
                if (!state.audiuno.heartbeatTimes) {
                    state.audiuno.heartbeatTimes = [];
                }
                state.audiuno.heartbeatTimes.push(state.baseTime);
                
                // 如果当前是"无效果"模式，需要重新创建 modifier 以应用心跳波浪
                if (state.splatMesh && state.effectParams.effect === 'None') {
                    console.log('首次收到心跳数据，在无效果模式下重新创建 modifier');
                    setupSplatModifier(state.splatMesh, 'None');
                    if (state.splatMesh.updateVersion) {
                        state.splatMesh.updateVersion();
                    }
                }
            }

            // 将心率映射到效果参数
            // 正常心率范围：60-100 BPM，映射到 intensity: 0.3-1.0
            // 或者映射到动画速度等其他参数
            if (state.audiuno.usePhysiological && state.splatMesh) {
                // 映射心率到 intensity (60-100 BPM -> 0.3-1.0)
                const normalizedHR = Math.max(0, Math.min(1, (hr - 60) / 40));
                const mappedIntensity = 0.3 + normalizedHR * 0.7;
                
                // 更新效果参数
                state.effectParams.intensity = mappedIntensity;
                
                // 更新 UI
                const intensitySlider = document.getElementById('intensity-slider');
                const intensityValue = document.getElementById('intensity-value');
                if (intensitySlider && intensityValue) {
                    intensitySlider.value = mappedIntensity;
                    intensityValue.textContent = mappedIntensity.toFixed(2);
                }

                // 重新应用效果
                if (state.effectParams.effect !== 'None') {
                    setupSplatModifier(state.splatMesh, state.effectParams.effect);
                    if (state.splatMesh.updateVersion) {
                        state.splatMesh.updateVersion();
                    }
                }
            }
        }

        // 基于心率预测心跳事件（如果 audiuno 只发送心率值，不发送心跳事件）
        function predictHeartbeat() {
            if (!state.audiuno.usePhysiological || state.audiuno.heartRate <= 0) return;
            
            // 计算心跳间隔（秒）
            const heartbeatInterval = 60.0 / state.audiuno.heartRate;
            
            // 如果距离上次心跳的时间超过间隔，触发新心跳
            const timeSinceLastBeat = state.baseTime - state.audiuno.lastHeartbeatTime;
            if (timeSinceLastBeat >= heartbeatInterval) {
                state.audiuno.lastHeartbeatTime = state.baseTime;
                // 添加到心跳历史记录
                if (!state.audiuno.heartbeatTimes) {
                    state.audiuno.heartbeatTimes = [];
                }
                state.audiuno.heartbeatTimes.push(state.baseTime);
                // 只保留最近 5 次心跳
                if (state.audiuno.heartbeatTimes.length > 5) {
                    state.audiuno.heartbeatTimes.shift();
                }
                console.log('💓 预测心跳:', state.audiuno.heartRate, 'BPM, 历史记录:', state.audiuno.heartbeatTimes.length);
            }
        }

        // Audiuno 连接按钮事件
        document.getElementById('connect-audiuno-btn').addEventListener('click', async () => {
            if (state.audiuno.isConnected) {
                await disconnectAudiuno();
            } else {
                await connectAudiuno();
            }
        });

        // 是否接受心跳数据开关
        const useHeartbeatToggle = document.getElementById('use-heartbeat-toggle');
        if (useHeartbeatToggle) {
            useHeartbeatToggle.addEventListener('change', () => {
                state.audiuno.usePhysiological = !!useHeartbeatToggle.checked;
                if (!state.audiuno.usePhysiological) {
                    // 关闭时清空心跳时间，避免残留波浪
                    state.audiuno.lastHeartbeatTime = 0;
                } else if (state.audiuno.heartRate > 0 && state.audiuno.lastHeartbeatTime === 0) {
                    // 重新开启时，初始化一个心跳时间
                    state.audiuno.lastHeartbeatTime = state.baseTime;
                }
            });
        }

        loadLocations();
        setInterval(loadLocations, 20000);
        updateLangUI();
    </script>
</body>
</html>
