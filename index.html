<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HK 3DGS Hub | Pro Holographic Map</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
    <style>
        :root { --primary: #00ff88; --danger: #ff4444; --glass: rgba(10, 15, 30, 0.95); --accent: #0072ff; }
        body, html { margin: 0; padding: 0; height: 100%; background: #000; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }
        #map-background { position: absolute; inset: 0; z-index: 1; }
        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 1000; }
        .pointer-auto { pointer-events: auto; }
        
        #btn-group { position: absolute; top: 20px; left: 20px; display: flex; flex-direction: column; gap: 10px; z-index: 1001; }
        .control-btn { background: var(--glass); color: white; border: 1px solid #444; padding: 10px 18px; border-radius: 20px; cursor: pointer; pointer-events: auto; font-size: 0.9em; }
        
        #upload-btn { position: absolute; top: 20px; right: 20px; background: var(--accent); border: none; padding: 12px 24px; border-radius: 50px; color: white; font-weight: bold; cursor: pointer; z-index: 1001; pointer-events: auto; }
        #info-bar { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 450px; background: var(--glass); padding: 20px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1); color: white; display: none; }
        #splat-viewer { position: absolute; inset: 0; background: #000; z-index: 2000; display: none; }
        #close-splat { position: absolute; top: 20px; left: 20px; z-index: 2100; padding: 10px 20px; border-radius: 20px; background: rgba(255,255,255,0.2); color: white; border: 1px solid white; cursor: pointer; }
        
        #loading-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; color: white; z-index: 2050; text-align: center; }
        .spinner { width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.1); border-left-color: var(--primary); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
    <script type="importmap">{ "imports": { 
        "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js"
    }}</script>
</head>
<body>
    <div id="map-background"></div>

    <div id="splat-viewer" class="pointer-auto">
        <div id="loading-overlay">
            <div class="spinner"></div>
            <div id="loading-status">ğŸš€ æ­£åœ¨å¼ºåˆ¶åŠ è½½ PLY 3DGS æ¨¡å‹...</div>
            <small style="opacity: 0.6; margin-top: 10px;">é€šè¿‡æšä¸¾å¼ºåˆ¶æŒ‡å®šè§£æè·¯å¾„</small>
        </div>
        <button id="close-splat">â† è¿”å›åœ°å›¾</button>
    </div>

    <div id="ui-layer">
        <div id="btn-group">
            <button id="style-toggle" class="control-btn">ğŸŒ™ æ·±è‰²é£æ ¼</button>
        </div>
        <button id="upload-btn">+ æ–°å¢ä»»åŠ¡</button>
        <div id="info-bar" class="pointer-auto">
            <h3 id="loc-title" style="margin:0"></h3>
            <p id="loc-desc" style="color:#aaa; font-size:0.85em; margin:10px 0;"></p>
            <button id="enter-btn" style="width:100%; background:var(--primary); border:none; padding:12px; border-radius:20px; cursor:pointer; font-weight:bold; color:#000;">è¿›å…¥å…¨æ¯å½±åƒ</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
    <script type="module">
        import * as THREE from 'three';
        import * as GaussianSplats3D from 'https://cdn.jsdelivr.net/npm/@mkkellogg/gaussian-splats-3d@0.4.6/build/gaussian-splats-3d.module.js';

        const REPO_ID = "ColinWong24/my-gaussian-world";
        const state = { locations: [], currentLoc: null, viewer: null };

        // 1. åœ°å›¾åˆå§‹åŒ– [web:122]
        const map = L.map('map-background', { center: [22.3193, 114.1694], zoom: 13, zoomControl: false });
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png').addTo(map);
        const markerGroup = L.layerGroup().addTo(map);

        async function loadLocations() {
            try {
                const res = await fetch(`https://huggingface.co/datasets/${REPO_ID}/resolve/main/locations.json?t=${Date.now()}`);
                state.locations = await res.json();
                markerGroup.clearLayers();
                state.locations.forEach(loc => {
                    const ready = loc.status === 'ready';
                    L.circleMarker([loc.lat, loc.lon], { 
                        radius: 10, fillColor: ready ? '#00ff88' : '#666', 
                        fillOpacity: 0.8, color: '#fff', weight: 2 
                    }).addTo(markerGroup).on('click', () => {
                        state.currentLoc = loc;
                        document.getElementById('loc-title').innerText = loc.name;
                        document.getElementById('loc-desc').innerText = loc.desc || "å¤„ç†ä¸­...";
                        document.getElementById('info-bar').style.display = 'block';
                        document.getElementById('enter-btn').disabled = !ready;
                        document.getElementById('enter-btn').style.opacity = ready ? "1" : "0.5";
                    });
                });
            } catch(e) { console.warn("Syncing..."); }
        }

        // PLY æ–‡ä»¶é¢„å¤„ç†ï¼šç§»é™¤é¢å¤–å…ƒç´ ï¼Œåªä¿ç•™ vertex å…ƒç´ 
        function preprocessPlyFile(arrayBuffer) {
            const textDecoder = new TextDecoder('utf-8', { fatal: false });
            const headText = textDecoder.decode(arrayBuffer.slice(0, Math.min(8192, arrayBuffer.byteLength)));
            
            // æŸ¥æ‰¾ end_header ä½ç½®
            const endHeaderIndex = headText.indexOf('end_header');
            if (endHeaderIndex === -1) {
                throw new Error('æ— æ³•æ‰¾åˆ° end_header æ ‡è®°');
            }
            
            // è§£ææ–‡ä»¶å¤´ï¼Œæ‰¾åˆ° vertex å…ƒç´ 
            const lines = headText.substring(0, endHeaderIndex).split('\n');
            let vertexElementFound = false;
            let vertexCount = 0;
            let vertexProperties = [];
            let dataOffset = endHeaderIndex + 'end_header'.length;
            
            // è·³è¿‡æ¢è¡Œç¬¦
            while (dataOffset < arrayBuffer.byteLength) {
                const byte = new Uint8Array(arrayBuffer)[dataOffset];
                if (byte === 0x0A || byte === 0x0D) {
                    dataOffset++;
                } else {
                    break;
                }
            }
            
            // è§£ææ–‡ä»¶å¤´
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith('element vertex')) {
                    vertexElementFound = true;
                    const match = line.match(/element\s+vertex\s+(\d+)/i);
                    if (match) {
                        vertexCount = parseInt(match[1]);
                        console.log(`ğŸ“Š æ‰¾åˆ° vertex å…ƒç´ : ${vertexCount.toLocaleString()} ä¸ªé¡¶ç‚¹`);
                    }
                } else if (vertexElementFound && line.startsWith('property')) {
                    vertexProperties.push(line);
                } else if (line.startsWith('element ') && !line.startsWith('element vertex')) {
                    // é‡åˆ°å…¶ä»–å…ƒç´ ï¼Œåœæ­¢æ”¶é›† vertex å±æ€§
                    break;
                }
            }
            
            if (!vertexElementFound || vertexCount === 0) {
                throw new Error('PLY æ–‡ä»¶ä¸­æœªæ‰¾åˆ° vertex å…ƒç´ ');
            }
            
            // è®¡ç®—æ¯ä¸ª vertex çš„å­—èŠ‚å¤§å°
            let vertexSize = 0;
            vertexProperties.forEach(prop => {
                if (prop.includes('float')) {
                    vertexSize += 4;
                } else if (prop.includes('uint') || prop.includes('int')) {
                    vertexSize += 4;
                } else if (prop.includes('uchar') || prop.includes('char')) {
                    vertexSize += 1;
                }
            });
            
            console.log(`ğŸ“ æ¯ä¸ª vertex å¤§å°: ${vertexSize} å­—èŠ‚`);
            console.log(`ğŸ“ Vertex æ•°æ®æ€»å¤§å°: ${(vertexCount * vertexSize / 1024 / 1024).toFixed(2)} MB`);
            
            // æ„å»ºæ–°çš„ PLY æ–‡ä»¶å¤´ï¼ˆåªåŒ…å« vertex å…ƒç´ ï¼‰
            let newHeader = 'ply\n';
            newHeader += 'format binary_little_endian 1.0\n';
            newHeader += `element vertex ${vertexCount}\n`;
            vertexProperties.forEach(prop => {
                newHeader += prop + '\n';
            });
            newHeader += 'end_header\n';
            
            const newHeaderBytes = new TextEncoder().encode(newHeader);
            const vertexDataSize = vertexCount * vertexSize;
            
            // æå– vertex æ•°æ®
            const vertexData = arrayBuffer.slice(dataOffset, dataOffset + vertexDataSize);
            
            // åˆ›å»ºæ–°çš„ ArrayBuffer
            const newPlyBuffer = new ArrayBuffer(newHeaderBytes.length + vertexDataSize);
            const newPlyView = new Uint8Array(newPlyBuffer);
            
            // å¤åˆ¶æ–‡ä»¶å¤´
            newPlyView.set(newHeaderBytes, 0);
            
            // å¤åˆ¶ vertex æ•°æ®
            newPlyView.set(new Uint8Array(vertexData), newHeaderBytes.length);
            
            console.log(`âœ… PLY æ–‡ä»¶é¢„å¤„ç†å®Œæˆ: ${(newPlyBuffer.byteLength / 1024 / 1024).toFixed(2)} MB`);
            
            return newPlyBuffer;
        }

        // PLY æ–‡ä»¶éªŒè¯å‡½æ•°
        async function validatePlyFile(url) {
            try {
                const response = await fetch(url, { method: 'HEAD' });
                if (!response.ok) {
                    throw new Error(`æ–‡ä»¶ä¸å­˜åœ¨æˆ–æ— æ³•è®¿é—®: ${response.status}`);
                }
                const contentLength = response.headers.get('content-length');
                if (contentLength && parseInt(contentLength) < 100) {
                    throw new Error('æ–‡ä»¶å¤ªå°ï¼Œå¯èƒ½ä¸æ˜¯æœ‰æ•ˆçš„ PLY æ–‡ä»¶');
                }
                
                // è·å–æ–‡ä»¶å¤´éƒ¨è¿›è¡ŒéªŒè¯ï¼ˆè¯»å–æ›´å¤šå­—èŠ‚ä»¥æ£€æŸ¥äºŒè¿›åˆ¶æ ¼å¼ï¼‰
                const headResponse = await fetch(url, { 
                    headers: { 'Range': 'bytes=0-4095' } 
                });
                const headArrayBuffer = await headResponse.arrayBuffer();
                const headText = new TextDecoder('utf-8', { fatal: false }).decode(headArrayBuffer);
                
                // æ£€æŸ¥ PLY æ–‡ä»¶å¤´
                if (!headText.startsWith('ply') && !headText.startsWith('PLY')) {
                    throw new Error('æ–‡ä»¶ä¸æ˜¯æœ‰æ•ˆçš„ PLY æ ¼å¼ï¼ˆç¼ºå°‘ PLY å¤´éƒ¨æ ‡è¯†ï¼‰');
                }
                
                // æ£€æŸ¥æ–‡ä»¶æ ¼å¼ï¼ˆASCII è¿˜æ˜¯äºŒè¿›åˆ¶ï¼‰
                const isBinary = headText.includes('binary') || headText.includes('BINARY');
                const isAscii = headText.includes('ascii') || headText.includes('ASCII') || !isBinary;
                
                // æŸ¥æ‰¾æ–‡ä»¶å¤´ç»“æŸä½ç½®
                const endHeaderIndex = headText.indexOf('end_header');
                if (endHeaderIndex === -1) {
                    throw new Error('PLY æ–‡ä»¶å¤´ç¼ºå°‘ end_header æ ‡è®°');
                }
                
                // è®¡ç®—äºŒè¿›åˆ¶æ•°æ®å¼€å§‹ä½ç½®ï¼ˆend_header + æ¢è¡Œç¬¦ï¼‰
                const binaryDataStart = endHeaderIndex + 'end_header'.length;
                // è·³è¿‡å¯èƒ½çš„æ¢è¡Œç¬¦ï¼ˆ\n æˆ– \r\nï¼‰
                let dataOffset = binaryDataStart;
                while (dataOffset < headArrayBuffer.byteLength && 
                       (headText[dataOffset] === '\n' || headText[dataOffset] === '\r')) {
                    dataOffset++;
                }
                
                console.log('ğŸ“‹ PLY æ–‡ä»¶å¤´ä¿¡æ¯:');
                console.log('  - æ ¼å¼:', isBinary ? 'äºŒè¿›åˆ¶' : 'ASCII');
                console.log('  - æ–‡ä»¶å¤´ç»“æŸä½ç½®:', endHeaderIndex);
                console.log('  - äºŒè¿›åˆ¶æ•°æ®å¼€å§‹ä½ç½®:', dataOffset);
                console.log('  - æ–‡ä»¶å¤´é¢„è§ˆ:', headText.substring(0, Math.min(500, endHeaderIndex)));
                
                // æ£€æŸ¥æ˜¯å¦åŒ…å«å¿…è¦çš„ 3DGS å­—æ®µ
                const requiredFields = ['x', 'y', 'z', 'f_dc_0', 'f_dc_1', 'f_dc_2'];
                const hasRequiredFields = requiredFields.some(field => headText.includes(field));
                if (!hasRequiredFields) {
                    console.warn('è­¦å‘Š: PLY æ–‡ä»¶å¯èƒ½ä¸åŒ…å«æ ‡å‡† 3DGS å­—æ®µ');
                }
                
                // æ£€æŸ¥å…ƒç´ æ•°é‡æ˜¯å¦åˆç†ï¼ˆé¿å…å¼‚å¸¸å¤§çš„æ•°å€¼ï¼‰
                const elementMatches = headText.match(/element\s+(\w+)\s+(\d+)/gi);
                if (elementMatches) {
                    console.log('  - å…ƒç´ å®šä¹‰:', elementMatches);
                    elementMatches.forEach(match => {
                        const parts = match.match(/element\s+(\w+)\s+(\d+)/i);
                        if (parts) {
                            const elementName = parts[1];
                            const elementCount = parseInt(parts[2]);
                            console.log(`    * ${elementName}: ${elementCount.toLocaleString()} ä¸ª`);
                            if (elementCount > 100000000) { // è¶…è¿‡ 1 äº¿ä¸ªå…ƒç´ å¯èƒ½æœ‰é—®é¢˜
                                throw new Error(`æ–‡ä»¶å¤´ä¸­çš„å…ƒç´ æ•°é‡å¼‚å¸¸å¤§: ${elementName} = ${elementCount}ï¼Œå¯èƒ½æ˜¯æ–‡ä»¶æ ¼å¼é”™è¯¯`);
                            }
                        }
                    });
                }
                
                // å¦‚æœæ˜¯äºŒè¿›åˆ¶æ ¼å¼ï¼Œæ£€æŸ¥å‰å‡ ä¸ªæ•°æ®å­—èŠ‚
                if (isBinary && dataOffset < headArrayBuffer.byteLength) {
                    const dataView = new DataView(headArrayBuffer);
                    console.log('  - äºŒè¿›åˆ¶æ•°æ®å‰16å­—èŠ‚ (åå…­è¿›åˆ¶):');
                    const hexBytes = [];
                    for (let i = dataOffset; i < Math.min(dataOffset + 16, headArrayBuffer.byteLength); i++) {
                        hexBytes.push(dataView.getUint8(i).toString(16).padStart(2, '0'));
                    }
                    console.log('    ', hexBytes.join(' '));
                    
                    // æ£€æŸ¥å‰4ä¸ªå­—èŠ‚ï¼ˆå¯èƒ½æ˜¯ç¬¬ä¸€ä¸ªé¡¶ç‚¹çš„ x åæ ‡ï¼‰
                    if (dataOffset + 4 <= headArrayBuffer.byteLength) {
                        const firstFloat = dataView.getFloat32(dataOffset, true); // little-endian
                        const firstFloatBE = dataView.getFloat32(dataOffset, false); // big-endian
                        console.log('  - ç¬¬ä¸€ä¸ªæµ®ç‚¹æ•° (little-endian):', firstFloat);
                        console.log('  - ç¬¬ä¸€ä¸ªæµ®ç‚¹æ•° (big-endian):', firstFloatBE);
                    }
                }
                
                return { isBinary, isAscii, dataOffset, endHeaderIndex };
            } catch (err) {
                console.error('PLY æ–‡ä»¶éªŒè¯å¤±è´¥:', err);
                throw err;
            }
        }

        // 2. ä½¿ç”¨ antimatter15/splat åº“åŠ è½½ PLY æ–‡ä»¶
        document.getElementById('enter-btn').onclick = async () => {
            if (!state.currentLoc) return;
            const container = document.getElementById('splat-viewer');
            const loader = document.getElementById('loading-overlay');
            container.style.display = 'block';
            loader.style.display = 'flex';

            // æ¸…ç†æ—§åœºæ™¯
            if (state.renderer) {
                state.renderer.dispose();
                if (state.scene) {
                    state.scene.traverse((obj) => {
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) {
                            if (Array.isArray(obj.material)) {
                                obj.material.forEach(m => m.dispose());
                            } else {
                                obj.material.dispose();
                            }
                        }
                    });
                }
            }

            const rawUrl = `https://huggingface.co/datasets/${REPO_ID}/resolve/main/${state.currentLoc.splatPath}?t=${Date.now()}`;
            
            // è°ƒè¯•ä¿¡æ¯
            console.log('ğŸ“‚ æ•°æ®é›†ä»“åº“:', REPO_ID);
            console.log('ğŸ“„ PLY æ–‡ä»¶è·¯å¾„:', state.currentLoc.splatPath);
            console.log('ğŸ”— å®Œæ•´ URL:', rawUrl);
            console.log('ğŸ“š ä½¿ç”¨åº“: @mkkellogg/gaussian-splats-3d');
            
            // æ·»åŠ å…¨å±€é”™è¯¯æ•è·
            const originalErrorHandler = window.onerror;
            let arrayLengthErrorCaught = false;
            window.onerror = (msg, url, line, col, error) => {
                if (msg && msg.includes('Invalid typed array length')) {
                    console.error('âš ï¸ æ•è·åˆ°æ•°ç»„é•¿åº¦é”™è¯¯:', msg);
                    arrayLengthErrorCaught = true;
                    const statusEl = document.getElementById('loading-status');
                    if (statusEl) statusEl.innerText = 'âŒ æ–‡ä»¶è§£æé”™è¯¯ï¼ŒPLY æ ¼å¼å¯èƒ½ä¸å…¼å®¹';
                    return true; // é˜»æ­¢é»˜è®¤é”™è¯¯å¤„ç†
                }
                if (originalErrorHandler) {
                    return originalErrorHandler(msg, url, line, col, error);
                }
                return false;
            };
            
            try {
                const statusEl = document.getElementById('loading-status');
                if (statusEl) statusEl.innerText = 'ğŸ” æ­£åœ¨éªŒè¯ PLY æ–‡ä»¶æ ¼å¼...';
                await validatePlyFile(rawUrl);
                
                if (statusEl) statusEl.innerText = 'ğŸ“¥ æ­£åœ¨ä¸‹è½½æ–‡ä»¶...';
                
                // ä¸‹è½½æ–‡ä»¶
                const fileResponse = await fetch(rawUrl);
                if (!fileResponse.ok) {
                    throw new Error(`ä¸‹è½½å¤±è´¥: HTTP ${fileResponse.status} ${fileResponse.statusText}`);
                }
                const contentLength = fileResponse.headers.get('content-length');
                console.log('ğŸ“¦ æ–‡ä»¶å¤§å°:', contentLength ? `${(parseInt(contentLength) / 1024 / 1024).toFixed(2)} MB` : 'æœªçŸ¥');
                
                const arrayBuffer = await fileResponse.arrayBuffer();
                console.log('âœ… æ–‡ä»¶ä¸‹è½½å®Œæˆï¼Œå®é™…å¤§å°:', `${(arrayBuffer.byteLength / 1024 / 1024).toFixed(2)} MB`);
                
                // é¢„å¤„ç† PLY æ–‡ä»¶ï¼šç§»é™¤é¢å¤–å…ƒç´ ï¼Œåªä¿ç•™ vertex
                if (statusEl) statusEl.innerText = 'ğŸ”§ æ­£åœ¨é¢„å¤„ç† PLY æ–‡ä»¶...';
                let processedBuffer;
                try {
                    processedBuffer = preprocessPlyFile(arrayBuffer);
                    console.log('âœ… PLY æ–‡ä»¶é¢„å¤„ç†æˆåŠŸ');
                } catch (preprocessErr) {
                    console.warn('âš ï¸ PLY é¢„å¤„ç†å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹æ–‡ä»¶:', preprocessErr);
                    processedBuffer = arrayBuffer; // å¦‚æœé¢„å¤„ç†å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹æ–‡ä»¶
                }
                
                // æ¸…ç†æ—§è§†å›¾
                if (state.viewer) {
                    try {
                        state.viewer.dispose();
                    } catch(e) {}
                    state.viewer = null;
                }
                
                if (statusEl) statusEl.innerText = 'ğŸš€ æ­£åœ¨åˆå§‹åŒ– Gaussian Splatting æŸ¥çœ‹å™¨...';
                
                // åˆå§‹åŒ– GaussianSplats3D Viewer
                state.viewer = new GaussianSplats3D.Viewer({
                    rootElement: container,
                    cameraUp: [0, -1, 0],
                    sharedMemoryForWorkers: false,
                    webWorkerCount: 0,
                    showSceneStatePlaceholder: false
                });
                
                await state.viewer.init();
                console.log('âœ… Viewer åˆå§‹åŒ–å®Œæˆ');
                
                if (statusEl) statusEl.innerText = 'ğŸ¨ æ­£åœ¨åŠ è½½ PLY æ¨¡å‹...';
                
                // ä½¿ç”¨ Blob URL åŠ è½½ï¼ˆä½¿ç”¨é¢„å¤„ç†åçš„ ArrayBufferï¼‰
                const blob = new Blob([processedBuffer], { type: 'application/octet-stream' });
                const blobUrl = URL.createObjectURL(blob);
                
                console.log('ğŸ“¦ ä½¿ç”¨ Blob URL åŠ è½½:', blobUrl);
                
                // å°è¯•ä½¿ç”¨ addSplatScene åŠ è½½
                try {
                    await state.viewer.addSplatScene(blobUrl, {
                        'format': 1, // PLY æ ¼å¼
                        'showLoadingUI': false,
                        'progressiveLoad': false,
                        'onSceneLoad': () => {
                            URL.revokeObjectURL(blobUrl);
                            loader.style.display = 'none';
                            state.viewer.start();
                            console.log('âœ… åœºæ™¯åŠ è½½å®Œæˆ');
                        }
                    });
                    
                    // è‡ªåŠ¨å±…ä¸­
                    setTimeout(() => {
                        try {
                            const mesh = state.viewer.getSplatMesh();
                            if (mesh) {
                                const box = new THREE.Box3().setFromObject(mesh);
                                const center = box.getCenter(new THREE.Vector3());
                                mesh.position.sub(center);
                                console.log('âœ… æ¨¡å‹å·²å±…ä¸­');
                            }
                        } catch(e) {
                            console.warn('âš ï¸ è‡ªåŠ¨å±…ä¸­å¤±è´¥:', e);
                        }
                    }, 500);
                    
                } catch (loadErr) {
                    console.error('âŒ addSplatScene å¤±è´¥:', loadErr);
                    URL.revokeObjectURL(blobUrl);
                    throw loadErr;
                }
                
                loader.style.display = 'none';
                console.log('âœ… æ¨¡å‹åŠ è½½å®Œæˆ');
                
            } catch (err) {
                console.error("åŠ è½½å¤±è´¥:", err);
                window.onerror = originalErrorHandler; // æ¢å¤é”™è¯¯å¤„ç†
                loader.style.display = 'none';
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯æ•°ç»„é•¿åº¦é”™è¯¯
                const isArrayLengthError = arrayLengthErrorCaught || 
                    (err.message && err.message.includes('Invalid typed array length')) ||
                    (err.toString && err.toString().includes('Invalid typed array length'));
                
                if (isArrayLengthError) {
                    const errorMsg = `PLY æ–‡ä»¶è§£æå¤±è´¥ï¼šæ•°ç»„é•¿åº¦é”™è¯¯\n\n` +
                        `å¯èƒ½åŸå› ï¼š\n` +
                        `1. PLY æ–‡ä»¶åŒ…å«é¢å¤–çš„å…ƒç´ ï¼ˆextrinsic, intrinsic, image_size ç­‰ï¼‰ï¼Œå¯¼è‡´åº“è§£ææ··ä¹±\n` +
                        `2. æ–‡ä»¶å¤´ä¸­çš„æ•°å€¼è§£æé”™è¯¯ï¼ˆå­—èŠ‚åºé—®é¢˜ï¼‰\n` +
                        `3. æ–‡ä»¶æ ¼å¼ä¸å®Œå…¨å…¼å®¹å½“å‰çš„ Gaussian Splatting åº“\n\n` +
                        `å»ºè®®ï¼š\n` +
                        `- æ£€æŸ¥ PLY æ–‡ä»¶æ˜¯å¦åªåŒ…å« vertex å…ƒç´ \n` +
                        `- å°è¯•ä½¿ç”¨å…¶ä»–å·¥å…·é‡æ–°ç”Ÿæˆ PLY æ–‡ä»¶\n` +
                        `- æˆ–è€…ä½¿ç”¨æ”¯æŒæ›´å¤š PLY å…ƒç´ æ ¼å¼çš„æŸ¥çœ‹å™¨\n\n` +
                        `æ–‡ä»¶è·¯å¾„: ${state.currentLoc.splatPath}`;
                    alert(errorMsg);
                } else {
                    alert(`æ¨¡å‹åŠ è½½å¤±è´¥ï¼š\n\né”™è¯¯: ${err.message || err}\n\nè¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æ­£ç¡®ä¸Šä¼ åˆ° HuggingFace æ•°æ®é›†ã€‚`);
                }
            }
        };

        document.getElementById('close-splat').onclick = () => {
            document.getElementById('splat-viewer').style.display = 'none';
            if (state.viewer) {
                try {
                    state.viewer.stop();
                    state.viewer.dispose();
                } catch(e) {}
                state.viewer = null;
            }
        };

        loadLocations();
    </script>
</body>
</html>
