<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HK 3DGS Hub | Pro Holographic Map</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
    <style>
        :root { --primary: #00ff88; --danger: #ff4444; --glass: rgba(10, 15, 30, 0.95); --accent: #0072ff; }
        body, html { margin: 0; padding: 0; height: 100%; background: #000; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        #map-background { position: absolute; inset: 0; z-index: 1; }
        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 1000; }
        .pointer-auto { pointer-events: auto; }
        #app-title { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: white; font-size: 28px; font-weight: 300; letter-spacing: 2px; z-index: 1001; pointer-events: none; text-shadow: 0 2px 10px rgba(0,0,0,0.5); }
        #lang-toggle { position: absolute; top: 20px; left: 20px; background: var(--glass); color: white; border: 1px solid #444; padding: 8px 15px; border-radius: 20px; cursor: pointer; z-index: 1001; }
        #map-style-toggle { position: absolute; top: 20px; left: 90px; background: var(--glass); color: white; border: 1px solid #444; padding: 8px 15px; border-radius: 20px; cursor: pointer; z-index: 1001; font-size: 0.9em; }
        #upload-btn { position: absolute; top: 20px; right: 20px; background: var(--accent); border: none; padding: 12px 24px; border-radius: 50px; color: white; font-weight: bold; cursor: pointer; z-index: 1001; }
        #info-bar { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 450px; background: var(--glass); padding: 20px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1); color: white; display: none; }
        #splat-viewer { position: absolute; inset: 0; background: transparent; z-index: 9999; display: none; }
        /* ç¡®ä¿ splat-viewer æœ¬èº«ä¸é˜»æŒ¡é¼ æ ‡äº‹ä»¶ï¼Œåªæœ‰å­å…ƒç´ å¯ä»¥äº¤äº’
           å…è®¸è¿”å›æŒ‰é’®ã€æ•ˆæœæ§åˆ¶é¢æ¿ã€è¯­è¨€åˆ‡æ¢æŒ‰é’®å’ŒèŠå¤©çª—å£æ¥æ”¶é¼ æ ‡äº‹ä»¶ */
        #splat-viewer > *:not(canvas):not(#close-splat):not(#chat-window):not(#effect-controls):not(#view-lang-toggle):not(#chat-toggle-btn) { pointer-events: none; }
        #close-splat { position: absolute; top: 20px; left: 20px; z-index: 2100; padding: 10px 20px; border-radius: 20px; background: rgba(255,255,255,0.2); color: white; border: 1px solid white; cursor: pointer; pointer-events: auto; }
        #effect-controls { position: absolute; top: 20px; left: 200px; z-index: 2100; background: var(--glass); border-radius: 15px; border: 1px solid #333; padding: 15px; min-width: 200px; pointer-events: auto; display: none; }
        #effect-controls label { color: white; font-size: 0.9em; display: block; margin-bottom: 8px; }
        #effect-select { width: 100%; padding: 8px; background: #050510; border: 1px solid #444; color: white; border-radius: 8px; cursor: pointer; margin-bottom: 10px; }
        #intensity-control { margin-bottom: 10px; }
        #intensity-control label { display: block; margin-bottom: 5px; }
        #intensity-slider { width: 100%; }
        #reset-time-btn { width: 100%; padding: 8px; background: var(--accent); border: 1px solid #444; color: white; border-radius: 8px; cursor: pointer; font-size: 0.85em; margin-bottom: 10px; }
        #audiuno-controls { margin-top: 10px; padding-top: 10px; border-top: 1px solid #333; }
        #audiuno-status { font-size: 0.8em; color: #aaa; margin-bottom: 5px; }
        #connect-audiuno-btn { width: 100%; padding: 8px; background: #00ff88; border: 1px solid #444; color: #000; border-radius: 8px; cursor: pointer; font-size: 0.85em; font-weight: bold; }
        #audiuno-toggle-row { margin-top: 8px; display: flex; align-items: center; gap: 8px; color: #ddd; font-size: 0.85em; }
        #audiuno-toggle-row input { width: auto; margin: 0; }
        #heart-rate-display { font-size: 0.9em; color: #00ff88; margin-top: 5px; }
        #view-lang-toggle { position: absolute; top: 20px; right: 360px; z-index: 2100; padding: 10px 20px; border-radius: 20px; background: rgba(255,255,255,0.2); color: white; border: 1px solid white; cursor: pointer; pointer-events: auto; display: none; }
        /* ä¸ºäº†ç¡®ä¿ 3D ç”»å¸ƒå¯äº¤äº’ï¼ŒèŠå¤©çª—å£ä¸æ‹¦æˆªé¼ æ ‡äº‹ä»¶ */
        #chat-window { position: absolute; bottom: 20px; right: 20px; width: 320px; height: 400px; max-height: 70vh; background: var(--glass); border-radius: 15px; border: 1px solid #333; display: none; flex-direction: column; z-index: 2100; box-shadow: 0 12px 40px rgba(0,0,0,0.6); overflow: hidden; }
        #chat-msgs { flex: 1; padding: 12px; overflow-y: auto; font-size: 0.85em; color: #eee; display: flex; flex-direction: column; gap: 10px; }
        .msg { padding: 10px 14px; border-radius: 12px; max-width: 85%; }
        .msg-agent { background: var(--accent); align-self: flex-start; }
        .msg-user { background: #333; align-self: flex-end; }
        #chat-input-wrap { display: flex; border-top: 1px solid #333; padding: 10px; background: rgba(0,0,0,0.3); }
        #chat-input { flex: 1; background: transparent; border: none; color: white; outline: none; }
        #modal-overlay { display: none; position: absolute; inset: 0; background: rgba(0,0,0,0.85); justify-content: center; align-items: center; z-index: 3000; pointer-events: auto; }
        .modal-box { background: #151525; padding: 25px; border-radius: 16px; width: 90%; max-width: 400px; color: white; border: 1px solid #333; }
        input, textarea { width: 100%; box-sizing: border-box; background: #050510; border: 1px solid #444; color: white; padding: 12px; border-radius: 8px; margin: 10px 0; }
        /* åŠ è½½æç¤ºï¼šæ”¹ä¸ºå³ä¸Šè§’å°å¾½æ ‡ï¼Œè€Œä¸æ˜¯å…¨å±é®ç½©ï¼Œä¸”ä¸æ‹¦æˆªäº¤äº’ */
        #loading-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            min-width: 160px;
            padding: 6px 14px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 12px;
            z-index: 2100;
            pointer-events: none;
        }
        /* ç¡®ä¿æ‰€æœ‰ canvas éƒ½å¯ä»¥äº¤äº’ï¼Œä¸»æ¸²æŸ“ canvas åœ¨æœ€ä¸Šå±‚ */
        #splat-viewer canvas { pointer-events: auto !important; position: absolute !important; top: 0 !important; left: 0 !important; width: 100% !important; height: 100% !important; z-index: 100 !important; }

        /* AI èŠå¤©æŠ˜å æŒ‰é’® */
        #chat-toggle-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 2101;
            padding: 8px 14px;
            border-radius: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            border: 1px solid #444;
            cursor: pointer;
            pointer-events: auto;
            font-size: 0.85em;
        }

        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 768px) {
            #app-title {
                top: 10px;
                font-size: 20px;
            }
            #lang-toggle, #map-style-toggle, #upload-btn {
                padding: 6px 10px;
                font-size: 12px;
            }
            #map-style-toggle {
                left: 80px;
            }
            #upload-btn {
                top: 60px;
                right: 10px;
                padding: 8px 14px;
            }
            #info-bar {
                bottom: 10px;
                width: 94%;
                padding: 12px;
            }
            #effect-controls {
                top: auto;
                bottom: 80px;
                left: 10px;
                right: 10px;
                min-width: 0;
                width: auto;
            }
            #view-lang-toggle {
                top: 20px;
                right: 20px;
            }
            #chat-window {
                left: 0;
                right: 0;
                bottom: 0;
                width: 100%;
                height: 45vh;
                border-radius: 16px 16px 0 0;
            }
            #chat-toggle-btn {
                bottom: 50px;
                right: 15px;
            }
        }
    </style>
    <script type="importmap">{ "imports": { 
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.178.0/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/",
            "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.10/spark.module.js",
            "@huggingface/hub": "https://cdn.jsdelivr.net/npm/@huggingface/hub@0.15.1/+esm"
    }}</script>
</head>
<body>
    <div id="map-background"></div>
    <div id="splat-viewer" class="pointer-auto">
        <div id="loading-overlay"></div>
        <button id="close-splat">â† è¿”å›åœ°å›¾</button>
        <div id="effect-controls">
            <label for="effect-select">âœ¨ è§†è§‰æ•ˆæœï¼š</label>
            <select id="effect-select">
                <option value="None">æ— æ•ˆæœ</option>
                <optgroup label="Reveal Effects">
                    <option value="Magic">é­”æ³•</option>
                    <option value="Spread">æ‰©æ•£</option>
                    <option value="Unroll">å±•å¼€</option>
                    <option value="Twister">é¾™å·é£</option>
                    <option value="Rain">é›¨</option>
                </optgroup>
                <optgroup label="Shader Effects">
                    <option value="Waves">æ³¢æµª</option>
                    <option value="Disintegrate">åˆ†è§£</option>
                </optgroup>
            </select>
            <div id="intensity-control" style="display: none;">
                <label for="intensity-slider">å¼ºåº¦: <span id="intensity-value">0.8</span></label>
                <input type="range" id="intensity-slider" min="0" max="1" step="0.01" value="0.8">
            </div>
            <button id="reset-time-btn">ğŸ”„ é‡ç½®æ—¶é—´</button>
            <div id="audiuno-controls">
                <div id="audiuno-status">æœªè¿æ¥</div>
                <button id="connect-audiuno-btn">ğŸ”Œ è¿æ¥ Audiuno</button>
                <div id="audiuno-toggle-row">
                    <input type="checkbox" id="use-heartbeat-toggle" checked>
                    <label for="use-heartbeat-toggle" id="use-heartbeat-label">æ¥å—å¿ƒè·³æ•°æ®</label>
                </div>
                <div id="heart-rate-display" style="display: none;">å¿ƒç‡: <span id="heart-rate-value">--</span> BPM</div>
            </div>
        </div>
        <button id="view-lang-toggle">EN / ä¸­</button>
        <button id="chat-toggle-btn">AI èŠå¤©</button>
        <div id="chat-window">
            <div id="gemini-config-ui" style="padding:20px; text-align:center;">
                <p style="color:var(--primary); font-size:0.9em;">ğŸ‘¤ æ¿€æ´» AI å¯¼è§ˆå‘˜</p>
                <input type="password" id="user-gemini-key" placeholder="Gemini API Key...">
                <button id="save-key-btn" style="background:var(--accent); color:white; border:none; padding:10px; width:100%; border-radius:8px; cursor:pointer;">å¼€å¯ AI å¯¹è¯</button>
            </div>
            <div id="chat-main-ui" style="display:none; flex-direction:column; height:100%;">
                <div id="chat-msgs"></div>
                <div id="chat-input-wrap">
                    <input type="text" id="chat-input" placeholder="æé—®...">
                    <button id="chat-send" style="background:none; border:none; color:var(--primary); cursor:pointer;">å‘é€</button>
                </div>
            </div>
        </div>
    </div>

    <div id="ui-layer">
        <h1 id="app-title">Spatial Memory Map</h1>
        <button id="lang-toggle" class="pointer-auto">EN / ä¸­</button>
        <button id="map-style-toggle" class="pointer-auto">ğŸ—ºï¸ åœ°å›¾æ ·å¼</button>
        <button id="upload-btn" class="pointer-auto">+ æ–°å¢ä»»åŠ¡</button>
        <div id="info-bar" class="pointer-auto">
            <h3 id="loc-title" style="margin:0"></h3>
            <p id="loc-desc" style="color:#aaa; font-size:0.85em; margin:10px 0;"></p>
            <div style="display:flex; justify-content:space-between; gap:10px;">
                <button id="del-btn" style="background:var(--danger); border:none; padding:8px 15px; border-radius:10px; color:white; cursor:pointer; font-weight:bold;">åˆ é™¤</button>
                <button id="enter-btn" style="background:var(--primary); border:none; padding:10px 25px; border-radius:20px; cursor:pointer; font-weight:bold; color:#000;">å…¨æ¯æŸ¥çœ‹</button>
            </div>
        </div>
    </div>

    <div id="modal-overlay">
        <div class="modal-box">
            <h3 style="margin:0 0 15px 0">åˆ›å»ºé‡å»ºä»»åŠ¡</h3>
            <input type="password" id="hf-token" placeholder="Hugging Face Write Token">
            <input type="password" id="deepl-key" placeholder="DeepL API Key (å¯é€‰ï¼Œç”¨äºè‡ªåŠ¨ç¿»è¯‘)">
            <input type="text" id="loc-name" placeholder="åœ°ç‚¹åç§° (ä¸­æ–‡)">
            <input type="text" id="loc-name-en" placeholder="Location Name (Englishï¼Œç•™ç©ºå°†è‡ªåŠ¨ç¿»è¯‘)">
            <div style="display:flex; gap:8px;">
                <input type="text" id="lat-lon" readonly placeholder="ç‚¹å‡»åœ°å›¾æ‹¾å–åæ ‡">
                <button id="pick-btn" style="background:var(--accent); border:none; padding:0 15px; border-radius:8px; color:white; cursor:pointer;">æ‹¾å–</button>
            </div>
            <input type="file" id="photo-input" accept="image/*">
            <textarea id="desc-input" rows="2" placeholder="è¯·è¾“å…¥æè¿° (ä¸­æ–‡ï¼Œå°†è‡ªåŠ¨ç¿»è¯‘ä¸ºè‹±æ–‡)..."></textarea>
            <button id="submit-btn" style="width:100%; background:var(--primary); border:none; padding:12px; border-radius:8px; font-weight:bold; cursor:pointer; margin-top:10px;">ä¸Šä¼ ä»»åŠ¡</button>
            <button onclick="document.getElementById('modal-overlay').style.display='none'" style="width:100%; background:none; border:none; color:#888; margin-top:10px; cursor:pointer;">å–æ¶ˆ</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
    <script type="module">
        import { commit } from '@huggingface/hub';
        import * as THREE from 'three';
        import { SparkControls, SplatMesh, dyno } from '@sparkjsdev/spark';

        const REPO_ID = "ColinWong24/my-gaussian-world";
            const state = { locations: [], currentLoc: null, lang: 'cn', scene: null, camera: null, renderer: null, controls: null, splatMesh: null, animationId: null, resizeHandler: null, isPicking: false, selectedCoords: null, deeplKey: localStorage.getItem('DEEPL_KEY') || '', effectParams: { effect: 'None', intensity: 0.8 }, animateT: null, baseTime: 0, effectStartTime: 0, modelCenter: null, audiuno: { port: null, reader: null, heartRate: 0, isConnected: false, usePhysiological: true, lastHeartbeatTime: 0, heartbeatTimes: [], heartbeatPeaks: [] }, isInitializing: false, isChatOpen: false };
        let ACTIVE_GEMINI_KEY = localStorage.getItem('MY_GEMINI_KEY') || '';
        
        // DeepL è‡ªåŠ¨ç¿»è¯‘å‡½æ•°
        async function translateWithDeepL(text, targetLang = 'EN') {
            if (!state.deeplKey || !text) return text;
            try {
                const res = await fetch('https://api-free.deepl.com/v2/translate', {
                    method: 'POST',
                    headers: {
                        'Authorization': `DeepL-Auth-Key ${state.deeplKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: [text],
                        target_lang: targetLang
                    })
                });
                if (!res.ok) throw new Error(`DeepL API é”™è¯¯: ${res.status}`);
                const data = await res.json();
                return data.translations[0].text;
            } catch (e) {
                console.warn('DeepL ç¿»è¯‘å¤±è´¥:', e);
                return text; // ç¿»è¯‘å¤±è´¥æ—¶è¿”å›åŸæ–‡
            }
        }

        function updateLangUI() {
            const langBtn = document.getElementById('lang-toggle');
            if (langBtn) langBtn.innerText = state.lang === 'cn' ? 'EN / ä¸­' : 'ä¸­ / EN';

            // æ ¹æ®è¯­è¨€åˆ‡æ¢å½“å‰åœ°ç‚¹æ ‡é¢˜å’Œæè¿°ï¼ˆå¦‚æœæœ‰è‹±æ–‡å­—æ®µï¼‰
            if (state.currentLoc) {
                const loc = state.currentLoc;
                const titleEl = document.getElementById('loc-title');
                const descEl = document.getElementById('loc-desc');
                if (state.lang === 'cn') {
                    titleEl.innerText = loc.name || '';
                    descEl.innerText = loc.desc || 'å¤„ç†ä¸­...';
                } else {
                    titleEl.innerText = loc.name_en || loc.name || '';
                    descEl.innerText = loc.desc_en || loc.desc || 'Processing...';
                }
            }

            // åŒæ­¥æ›´æ–°åœ°å›¾æ ·å¼æŒ‰é’®çš„æ–‡æ¡ˆ
            updateMapStyleButton();
        }

        // ===== AI èŠå¤©ç›¸å…³ =====
        function addChatMessage(role, text) {
            const msgs = document.getElementById('chat-msgs');
            if (!msgs) return;
            const div = document.createElement('div');
            div.className = `msg msg-${role}`;
            div.innerText = text;
            msgs.appendChild(div);
            msgs.scrollTop = msgs.scrollHeight;
        }

        function showChatUI() {
            const chatWin = document.getElementById('chat-window');
            if (!chatWin) return;
            chatWin.style.display = 'flex';
            state.isChatOpen = true;

            const cfg = document.getElementById('gemini-config-ui');
            const main = document.getElementById('chat-main-ui');

            if (ACTIVE_GEMINI_KEY) {
                cfg.style.display = 'none';
                main.style.display = 'flex';
                // é¦–æ¬¡æ‰“å¼€å½“å‰åœ°ç‚¹æ—¶æ‰“ä¸ªæ‹›å‘¼ï¼ˆæ ¹æ®å½“å‰è¯­è¨€è®¾ç½®ï¼‰
                if (document.getElementById('chat-msgs').children.length === 0 && state.currentLoc) {
                    const locName = state.currentLoc.name || state.currentLoc.name_en || 'è¿™ä¸ªåœ°æ–¹';
                    if (state.lang === 'cn') {
                        addChatMessage('agent', `ä½ å¥½ï¼Œæˆ‘æ˜¯è¿™ä¸ªåœºæ™¯çš„æ‹æ‘„è€…ï¼Œç°åœ¨å¸¦ä½ çœ‹ï¼š${locName}ã€‚å¯ä»¥éšä¾¿é—®æˆ‘é—®é¢˜ï½`);
                    } else {
                        addChatMessage('agent', `Hi, I'm the photographer of this scene. Let me show you: ${locName}. Feel free to ask me anything!`);
                    }
                }
            } else {
                cfg.style.display = 'block';
                main.style.display = 'none';
            }
        }

        // æŠ˜å  / å±•å¼€ AI èŠå¤©çª—å£
        const chatToggleBtn = document.getElementById('chat-toggle-btn');
        if (chatToggleBtn) {
            chatToggleBtn.addEventListener('click', () => {
                const chatWin = document.getElementById('chat-window');
                if (!chatWin) return;
                const isHidden = chatWin.style.display === 'none' || chatWin.style.display === '';
                if (isHidden) {
                    showChatUI();
                } else {
                    chatWin.style.display = 'none';
                    state.isChatOpen = false;
                }
            });
        }

        // å°†å›¾ç‰‡ URL è½¬æ¢ä¸º base64
        async function imageUrlToBase64(imageUrl) {
            try {
                const response = await fetch(imageUrl);
                const blob = await response.blob();
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const base64 = reader.result.split(',')[1]; // ç§»é™¤ data:image/...;base64, å‰ç¼€
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (e) {
                console.error('å›¾ç‰‡è½¬æ¢å¤±è´¥:', e);
                return null;
            }
        }

        // æ£€æµ‹æ–‡æœ¬è¯­è¨€ï¼ˆç®€å•æ£€æµ‹ï¼šåŒ…å«ä¸­æ–‡å­—ç¬¦åˆ™ä¸ºä¸­æ–‡ï¼‰
        function detectLanguage(text) {
            // æ£€æµ‹æ˜¯å¦åŒ…å«ä¸­æ–‡å­—ç¬¦
            const chineseRegex = /[\u4e00-\u9fa5]/;
            return chineseRegex.test(text) ? 'cn' : 'en';
        }

        async function handleChat() {
            if (!ACTIVE_GEMINI_KEY) {
                alert('è¯·å…ˆåœ¨å³ä¸‹è§’è¾“å…¥ Gemini API Key');
                return;
            }
            const input = document.getElementById('chat-input');
            const text = (input.value || '').trim();
            if (!text) return;
            addChatMessage('user', text);
            input.value = '';

            // æ£€æµ‹ç”¨æˆ·è¾“å…¥çš„è¯­è¨€
            const userLang = detectLanguage(text);

            const loc = state.currentLoc || {};
            const locName = userLang === 'cn' ? (loc.name || loc.name_en || 'è¿™ä¸ªåœ°æ–¹') : (loc.name_en || loc.name || 'this place');
            const locDesc = userLang === 'cn' ? (loc.desc || loc.desc_en || '') : (loc.desc_en || loc.desc || '');
            
            // æ ¹æ®ç”¨æˆ·è¯­è¨€ç”Ÿæˆç³»ç»Ÿæç¤ºè¯
            const sys = userLang === 'cn' 
                ? `ä½ æ˜¯è¿™å¼ ç…§ç‰‡çš„æ‹æ‘„è€…ï¼Œä¹Ÿæ˜¯è¿™ä¸ª 3D å…¨æ¯åœºæ™¯çš„åˆ›å»ºè€…ã€‚ç”¨æˆ·æ­£åœ¨æŸ¥çœ‹ä½ æ‹æ‘„å¹¶é‡å»ºçš„åœºæ™¯ã€‚

ä½ çš„èº«ä»½ï¼šç…§ç‰‡æä¾›è€…
åœºæ™¯åœ°ç‚¹ï¼š${locName}
åœºæ™¯æè¿°ï¼š${locDesc}

è¯·ä»¥ç…§ç‰‡æ‹æ‘„è€…çš„ç¬¬ä¸€äººç§°èº«ä»½ï¼Œç”¨å£è¯­åŒ–ã€äº²åˆ‡çš„æ–¹å¼ä¸ç”¨æˆ·èŠå¤©ã€‚ä½ å¯ä»¥ï¼š
- åˆ†äº«æ‹æ‘„è¿™ä¸ªåœºæ™¯æ—¶çš„ç»å†å’Œæ„Ÿå—
- æè¿°åœºæ™¯ä¸­çš„ç»†èŠ‚å’Œç‰¹è‰²
- å›ç­”ç”¨æˆ·å…³äºåœºæ™¯çš„é—®é¢˜
- åŸºäºç…§ç‰‡å†…å®¹æä¾›æ›´å¤šèƒŒæ™¯ä¿¡æ¯

å›ç­”è¦ç®€çŸ­ã€è‡ªç„¶ï¼Œå¤šç”¨"å””"ã€"å•Š"ã€"å…¶å®"ã€"å½“æ—¶"ç­‰å£è¯­åŒ–è¡¨è¾¾ï¼Œå°±åƒå’Œæœ‹å‹èŠå¤©ä¸€æ ·ã€‚è¯·ç”¨ä¸­æ–‡å›å¤ã€‚`
                : `You are the photographer of this photo and the creator of this 3D holographic scene. The user is viewing the scene you photographed and reconstructed.

Your identity: Photo provider
Location: ${locName}
Scene description: ${locDesc}

Please chat with the user in a casual, friendly way as the photographer in first person. You can:
- Share your experiences and feelings when photographing this scene
- Describe the details and features of the scene
- Answer questions about the scene
- Provide more background information based on the photo content

Keep your answers brief and natural, use casual expressions like "well", "actually", "at that time", just like chatting with a friend. Please reply in English.`;

            try {
                // æ„å»ºè¯·æ±‚çš„ parts æ•°ç»„
                const parts = [{ text: sys }];
                
                // å¦‚æœæœ‰å›¾ç‰‡ï¼Œæ·»åŠ åˆ°è¯·æ±‚ä¸­
                if (loc.photoPath) {
                    const imageUrl = `https://huggingface.co/datasets/${REPO_ID}/resolve/main/${loc.photoPath}`;
                    const base64Image = await imageUrlToBase64(imageUrl);
                    if (base64Image) {
                        // æ ¹æ®æ–‡ä»¶æ‰©å±•åç¡®å®š MIME ç±»å‹
                        const mimeType = loc.photoPath.toLowerCase().endsWith('.png') ? 'image/png' : 'image/jpeg';
                        parts.push({
                            inlineData: {
                                mimeType: mimeType,
                                data: base64Image
                            }
                        });
                    }
                }
                
                // æ·»åŠ ç”¨æˆ·çš„é—®é¢˜
                parts.push({ text: text });

                // ä½¿ç”¨ gemini-1.5-flash ä½œä¸ºé»˜è®¤æ¨¡å‹ï¼ˆæ¨èç”¨äºå¿«é€Ÿå“åº”ï¼‰
                // å¦‚æœå¤±è´¥ï¼Œå°è¯•å…¶ä»–å¯ç”¨çš„æ¨¡å‹
                let modelName = 'gemini-1.5-flash';
                let res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${ACTIVE_GEMINI_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [
                            { role: 'user', parts: parts }
                        ]
                    })
                });
                
                // å¦‚æœå¤±è´¥ï¼Œå°è¯• gemini-1.5-pro
                if (!res.ok && (res.status === 400 || res.status === 404)) {
                    console.warn('gemini-1.5-flash å¤±è´¥ï¼Œå°è¯• gemini-1.5-pro');
                    modelName = 'gemini-1.5-pro';
                    res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${ACTIVE_GEMINI_KEY}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [
                                { role: 'user', parts: parts }
                            ]
                        })
                    });
                }
                
                // å¦‚æœè¿˜æ˜¯å¤±è´¥ï¼Œå°è¯• gemini-pro (æ—§ç‰ˆæœ¬ï¼Œå¯èƒ½å·²å¼ƒç”¨)
                if (!res.ok && (res.status === 400 || res.status === 404)) {
                    console.warn('gemini-1.5-pro å¤±è´¥ï¼Œå°è¯• gemini-pro');
                    modelName = 'gemini-pro';
                    res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${ACTIVE_GEMINI_KEY}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [
                                { role: 'user', parts: parts }
                            ]
                        })
                    });
                }
                
                if (!res.ok) {
                    const errorData = await res.json().catch(() => ({}));
                    console.error('Gemini API é”™è¯¯:', res.status, errorData);
                    throw new Error(`API é”™è¯¯ ${res.status}: ${errorData.error?.message || res.statusText}`);
                }
                
                const data = await res.json();
                const userLang = detectLanguage(text);
                const defaultReply = userLang === 'cn' 
                    ? 'å””ï¼Œæˆ‘ä¸€æ—¶é—´æœ‰ç‚¹æƒ³ä¸åˆ°ï¼Œç­‰æˆ‘å†ç ”ç©¶ä¸‹å…ˆï½'
                    : 'Well, I need to think about that for a moment...';
                const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || defaultReply;
                addChatMessage('agent', reply);
            } catch (e) {
                console.error('Gemini è°ƒç”¨å¤±è´¥:', e);
                const errorMsg = e.message || 'æœªçŸ¥é”™è¯¯';
                const userLang = detectLanguage(text);
                const errorMessage = userLang === 'cn'
                    ? `å””ï¼ŒAI é‚£è¾¹å‡ºé—®é¢˜äº†ï¼š${errorMsg}ã€‚è¯·æ£€æŸ¥ API Key æ˜¯å¦æ­£ç¡®ï¼Œæˆ–è€…ç¨åå†è¯•ã€‚`
                    : `Oops, there's a problem with the AI: ${errorMsg}. Please check if your API Key is correct, or try again later.`;
                addChatMessage('agent', errorMessage);
            }
        }

        // 1. åˆå§‹åŒ–åœ°å›¾ [web:13]
        const map = L.map('map-background', { center: [22.3193, 114.1694], zoom: 13, zoomControl: false });
        
        // åœ°å›¾æ ·å¼é…ç½®
        const mapStyles = {
            dark: {
                nameCn: 'æ·±è‰²',
                nameEn: 'Dark',
                url: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'
            },
            light: {
                nameCn: 'æµ…è‰²',
                nameEn: 'Light',
                url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png'
            },
            satellite: {
                nameCn: 'å«æ˜Ÿ',
                nameEn: 'Satellite',
                url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
            },
            terrain: {
                nameCn: 'åœ°å½¢',
                nameEn: 'Terrain',
                url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png'
            }
        };
        
        let currentMapStyle = 'dark';
        let currentTileLayer = L.tileLayer(mapStyles[currentMapStyle].url).addTo(map);
        const markerGroup = L.layerGroup().addTo(map);

        function updateMapStyleButton() {
            const btn = document.getElementById('map-style-toggle');
            if (!btn) return;
            const styleCfg = mapStyles[currentMapStyle];
            if (!styleCfg) return;
            const name = state.lang === 'cn' ? styleCfg.nameCn : styleCfg.nameEn;
            btn.innerText = `ğŸ—ºï¸ ${name}`;
        }
        
        // åœ°å›¾æ ·å¼åˆ‡æ¢åŠŸèƒ½
        document.getElementById('map-style-toggle').onclick = () => {
            const styles = Object.keys(mapStyles);
            const currentIndex = styles.indexOf(currentMapStyle);
            const nextIndex = (currentIndex + 1) % styles.length;
            currentMapStyle = styles[nextIndex];
            
            // ç§»é™¤æ—§å›¾å±‚
            map.removeLayer(currentTileLayer);
            
            // æ·»åŠ æ–°å›¾å±‚
            currentTileLayer = L.tileLayer(mapStyles[currentMapStyle].url).addTo(map);
            
            // æ›´æ–°æŒ‰é’®æ–‡æœ¬ï¼ˆæ ¹æ®å½“å‰è¯­è¨€æ˜¾ç¤ºä¸­/è‹±æ–‡ï¼‰
            updateMapStyleButton();
        };

        // 2. æ•°æ®åŠ è½½ä¸åŒæ­¥ [web:18]
        async function loadLocations() {
            try {
                const res = await fetch(`https://huggingface.co/datasets/${REPO_ID}/resolve/main/locations.json?t=${Date.now()}`);
                state.locations = await res.json();
                markerGroup.clearLayers();
                state.locations.forEach(loc => {
                    const ready = loc.status === 'ready';
                    L.circleMarker([loc.lat, loc.lon], { radius: 10, fillColor: ready ? '#00ff88' : '#ffcc00', fillOpacity: 0.8, color: '#fff', weight: 2 })
                    .addTo(markerGroup).on('click', () => {
                        state.currentLoc = loc;
                        state.currentLoc = loc;
                        // æ ¹æ®å½“å‰è¯­è¨€æ¸²æŸ“æ ‡é¢˜ä¸æè¿°
                        if (state.lang === 'cn') {
                            document.getElementById('loc-title').innerText = loc.name;
                            document.getElementById('loc-desc').innerText = loc.desc || "å¤„ç†ä¸­...";
                        } else {
                            document.getElementById('loc-title').innerText = loc.name_en || loc.name;
                            document.getElementById('loc-desc').innerText = loc.desc_en || loc.desc || "Processing...";
                        }
                        document.getElementById('info-bar').style.display = 'block';
                        document.getElementById('enter-btn').disabled = !ready;
                        document.getElementById('enter-btn').style.opacity = ready ? "1" : "0.5";
                    });
                });
            } catch(e) { console.error("åŠ è½½å¤±è´¥", e); }
        }

        // è®¾ç½® Splat è§†è§‰æ•ˆæœ
        function setupSplatModifier(splatMesh, effectType) {
            console.log('setupSplatModifier è°ƒç”¨ï¼ŒeffectType:', effectType, 'animateT å­˜åœ¨:', !!state.animateT);
            // ç¡®ä¿ animateT å·²åˆå§‹åŒ–
            if (!state.animateT) {
                console.warn('animateT æœªåˆå§‹åŒ–ï¼Œæ— æ³•åº”ç”¨æ•ˆæœï¼Œå°è¯•åˆå§‹åŒ–');
                state.animateT = dyno.dynoFloat(0);
                if (!state.animateT) {
                    console.error('æ— æ³•åˆå§‹åŒ– animateT');
                    return;
                }
            }
            
            // å¦‚æœé€‰æ‹©"æ— æ•ˆæœ"ï¼Œä½†å¯ç”¨äº†å¿ƒè·³æ•°æ®ï¼Œä»ç„¶éœ€è¦åˆ›å»º modifier æ¥åº”ç”¨å¿ƒè·³æ³¢æµª
            if (effectType === 'None') {
                // å¦‚æœæ²¡æœ‰å¿ƒè·³æ•°æ®ï¼Œç›´æ¥æ¸…é™¤æ•ˆæœ
                if (!state.audiuno.usePhysiological || state.audiuno.lastHeartbeatTime <= 0) {
                    splatMesh.objectModifier = null;
                    splatMesh.updateGenerator();
                    console.log('æ•ˆæœå·²æ¸…é™¤');
                    return;
                }
                // å¦‚æœæœ‰å¿ƒè·³æ•°æ®ï¼Œç»§ç»­åˆ›å»º modifier ä»¥åº”ç”¨å¿ƒè·³æ³¢æµªæ•ˆæœ
                console.log('æ— æ•ˆæœæ¨¡å¼ï¼Œä½†å°†åº”ç”¨å¿ƒè·³æ³¢æµªæ•ˆæœ');
            }

            // Reveal effects ä½¿ç”¨ 1-5ï¼ŒShader effects ä½¿ç”¨ 10-14
            const revealEffectMap = {
                'Magic': 1,
                'Spread': 2,
                'Unroll': 3,
                'Twister': 4,
                'Rain': 5
            };
            
            const shaderEffectMap = {
                'Waves': 12,
                'Disintegrate': 14
            };
            
            const effectTypeMap = {
                'None': 0,
                ...revealEffectMap,
                ...shaderEffectMap
            };

            const effectInt = effectTypeMap[effectType] ?? (effectType === 'None' ? 0 : 1);

            splatMesh.objectModifier = dyno.dynoBlock(
                { gsplat: dyno.Gsplat },
                { gsplat: dyno.Gsplat },
                ({ gsplat }) => {
                    const d = new dyno.Dyno({
                        inTypes: { gsplat: dyno.Gsplat, t: "float", effectType: "int", intensity: "float", heartbeatTime: "float", heartbeatTime1: "float", heartbeatTime2: "float", heartbeatTime3: "float" },
                        outTypes: { gsplat: dyno.Gsplat },
                        globals: () => [
                            dyno.unindent(`
                                vec3 hash(vec3 p) {
                                    return fract(sin(p*123.456)*123.456);
                                }

                                vec3 noise(vec3 p) {
                                    vec3 i = floor(p);
                                    vec3 f = fract(p);
                                    f = f * f * (3.0 - 2.0 * f);
                                    
                                    vec3 n000 = hash(i + vec3(0,0,0));
                                    vec3 n100 = hash(i + vec3(1,0,0));
                                    vec3 n010 = hash(i + vec3(0,1,0));
                                    vec3 n110 = hash(i + vec3(1,1,0));
                                    vec3 n001 = hash(i + vec3(0,0,1));
                                    vec3 n101 = hash(i + vec3(1,0,1));
                                    vec3 n011 = hash(i + vec3(0,1,1));
                                    vec3 n111 = hash(i + vec3(1,1,1));
                                    
                                    vec3 x0 = mix(n000, n100, f.x);
                                    vec3 x1 = mix(n010, n110, f.x);
                                    vec3 x2 = mix(n001, n101, f.x);
                                    vec3 x3 = mix(n011, n111, f.x);
                                    
                                    vec3 y0 = mix(x0, x1, f.y);
                                    vec3 y1 = mix(x2, x3, f.y);
                                    
                                    return mix(y0, y1, f.z);
                                }

                                mat2 rot(float a) {
                                    float s=sin(a),c=cos(a);
                                    return mat2(c,-s,s,c);
                                }

                                vec4 twister(vec3 pos, vec3 scale, float t) {
                                    vec3 h = hash(pos);
                                    float s = smoothstep(0., 8., t*t*.1 - length(pos.xz)*2.+2.);
                                    if (length(scale) < .05) pos.y = mix(-10., pos.y, pow(s, 2.*h.x));
                                    pos.xz = mix(pos.xz*.5, pos.xz, pow(s, 2.*h.x));
                                    float rotationTime = t * (1.0 - s) * 0.2;
                                    pos.xz *= rot(rotationTime + pos.y*20.*(1.-s)*exp(-1.*length(pos.xz)));
                                    return vec4(pos, s*s*s*s);
                                }

                                vec4 rain(vec3 pos, vec3 scale, float t) {
                                    vec3 h = hash(pos);
                                    float s = pow(smoothstep(0., 5., t*t*.1 - length(pos.xz)*2. + 1.), .5 + h.x);
                                    float y = pos.y;
                                    pos.y = min(-10. + s*15., pos.y);
                                    pos.xz = mix(pos.xz*.3, pos.xz, s);
                                    pos.xz *= rot(t*.3);
                                    return vec4(pos, smoothstep(-10., y, pos.y));
                                }

                                vec3 headMovement(vec3 pos, float t) {
                                    pos.xy *= rot(smoothstep(-1., -2., pos.y) * .2 * sin(t*2.));
                                    return pos;
                                }

                                vec3 breathAnimation(vec3 pos, float t) {
                                    float b = sin(t*1.5);
                                    pos.yz *= rot(smoothstep(-1., -3., pos.y) * .15 * -b);
                                    pos.z += .3;
                                    pos.y += 1.2;
                                    pos *= 1. + exp(-3. * length(pos)) * b;
                                    pos.z -= .3;
                                    pos.y -= 1.2;
                                    return pos;
                                }

                                vec4 fractal1(vec3 pos, float t, float intensity) {
                                    float m = 100.;
                                    vec3 p = pos * .1;
                                    p.y += .5;
                                    for (int i = 0; i < 8; i++) {
                                        p = abs(p) / clamp(abs(p.x * p.y), 0.3, 3.) - 1.;
                                        p.xy *= rot(radians(90.));
                                        if (i > 1) m = min(m, length(p.xy) + step(.3, fract(p.z * .5 + t * .5 + float(i) * .2)));
                                    }
                                    m = step(m, 0.5) * 1.3 * intensity;
                                    return vec4(-pos.y * .3, 0.5, 0.7, .3) * intensity + m;
                                }

                                vec4 fractal2(vec3 center, vec3 scales, vec4 rgba, float t, float intensity) {
                                    vec3 pos = center;
                                    float splatSize = length(scales);
                                    float pattern = exp(-50. * splatSize);
                                    vec3 p = pos * .65;
                                    pos.y += 2.;
                                    float c = 0.;
                                    float l, l2 = length(p);
                                    float m = 100.;
                                    
                                    for (int i = 0; i < 10; i++) {
                                        p.xyz = abs(p.xyz) / dot(p.xyz, p.xyz) - .8;
                                        l = length(p.xyz);
                                        c += exp(-1. * abs(l - l2) * (1. + sin(t * 1.5 + pos.y)));
                                        l2 = length(p.xyz);
                                        m = min(m, length(p.xyz));
                                    }
                                    
                                    c = smoothstep(0.3, 0.5, m + sin(t * 1.5 + pos.y * .5)) + c * .1;              
                                    return vec4(vec3(length(rgba.rgb)) * vec3(c, c*c, c*c*c) * intensity, 
                                              rgba.a * exp(-20. * splatSize) * m * intensity);
                                }

                                vec4 sin3D(vec3 p, float t) {
                                    float m = exp(-2. * length(sin(p * 5. + t * 3.))) * 5.;
                                    return vec4(m) + .3;
                                }

                                vec4 disintegrate(vec3 pos, float t, float intensity) {
                                    vec3 p = pos + (hash(pos) * 2. - 1.) * intensity;
                                    float tt = smoothstep(-1., 0.5, -sin(t + -pos.y * .5));  
                                    p.xz *= rot(tt * 2. + p.y * 2. * tt);
                                    return vec4(mix(p, pos, tt), tt);
                                }
                                
                                vec4 flare(vec3 pos, float t) {
                                    vec3 p = vec3(0., -1.5, 0.);
                                    float tt = smoothstep(-1., .5, sin(t + hash(pos).x));  
                                    tt = tt * tt;              
                                    p.x += sin(t * 2.) * tt;
                                    p.z += sin(t * 2.) * tt;
                                    p.y += sin(t) * tt;
                                    return vec4(mix(pos, p, tt), tt);
                                }

                                // å¿ƒè·³æ³¢æµªæ•ˆæœï¼šä»æ¨¡å‹ä¸­å¿ƒå‘å¤–ä¼ æ’­çš„æ³¢æµª
                                vec3 heartbeatWave(vec3 pos, float t, float heartbeatTime) {
                                    if (heartbeatTime <= 0.0) return pos;
                                    
                                    // è®¡ç®—ä»ä¸Šæ¬¡å¿ƒè·³åˆ°ç°åœ¨çš„æ—¶é—´
                                    float timeSinceBeat = t - heartbeatTime;
                                    
                                    // æ³¢æµªæŒç»­æ—¶é—´ï¼ˆçº¦ 1 ç§’ï¼‰
                                    float waveDuration = 1.0;
                                    if (timeSinceBeat < 0.0 || timeSinceBeat > waveDuration) return pos;
                                    
                                    // è®¡ç®—åˆ°æ¨¡å‹ä¸­å¿ƒçš„è·ç¦»
                                    float dist = length(pos);
                                    
                                    // è®¡ç®—æ³¢æµªå¼ºåº¦ï¼ˆè·ç¦»æ³¢æµªå‰æ²¿è¶Šè¿‘ï¼Œå¼ºåº¦è¶Šå¤§ï¼‰
                                    float waveSpeed = 4.0;
                                    float waveFront = timeSinceBeat * waveSpeed;
                                    float waveDist = abs(dist - waveFront);
                                    float waveIntensity = exp(-waveDist * 2.5) * (1.0 - timeSinceBeat / waveDuration);
                                    
                                    // åº”ç”¨å¾„å‘èµ·ä¼
                                    vec3 dir = normalize(pos);
                                    pos += dir * waveIntensity * 0.5;
                                    
                                    return pos;
                                }
                            `)
                        ],
                        statements: ({ inputs, outputs }) => dyno.unindentLines(`
                            ${outputs.gsplat} = ${inputs.gsplat};
                            
                            vec3 localPos = ${inputs.gsplat}.center;
                            vec3 splatScales = ${inputs.gsplat}.scales;
                            vec4 splatColor = ${inputs.gsplat}.rgba;
                            float t = ${inputs.t};
                            float heartbeatTime = ${inputs.heartbeatTime};
                            float heartbeatTime1 = ${inputs.heartbeatTime1};
                            float heartbeatTime2 = ${inputs.heartbeatTime2};
                            float heartbeatTime3 = ${inputs.heartbeatTime3};
                            float l = length(localPos.xz);
                            int effectType = int(${inputs.effectType});
                            
                            // æ— æ•ˆæœæ¨¡å¼ï¼ˆeffectType == 0ï¼‰ï¼šåªåœ¨æœ‰å¿ƒè·³æ•°æ®æ—¶åº”ç”¨ç±»ä¼¼ Magic æ•ˆæœçš„å¾„å‘å±•å¼€
                            if (effectType == 0) {
                                // ä½¿ç”¨æœ€è¿‘ä¸€æ¬¡å¿ƒè·³ï¼ˆheartbeatTime1 æ˜¯æœ€æ–°çš„ï¼‰
                                float activeBeat = heartbeatTime1 > 0.0 ? heartbeatTime1 : heartbeatTime;
                                if (activeBeat > 0.0) {
                                    // è®¡ç®—ä»ä¸Šæ¬¡å¿ƒè·³åˆ°ç°åœ¨çš„æ—¶é—´
                                    float timeSinceBeat = t - activeBeat;
                                    float waveDuration = 2.0; // å¿ƒè·³æ•ˆæœæŒç»­æ—¶é—´
                                    
                                    // åªåœ¨æ³¢æµªæŒç»­æ—¶é—´å†…åº”ç”¨æ•ˆæœï¼ˆæ¯æ¬¡å¿ƒè·³å®Œæ•´åˆ·æ–°ï¼‰
                                    if (timeSinceBeat >= 0.0 && timeSinceBeat <= waveDuration) {
                                        // ä½¿ç”¨ç±»ä¼¼ Magic æ•ˆæœçš„å¾„å‘å±•å¼€é€»è¾‘
                                        // s: ä»ä¸­å¿ƒå‘å¤–å±•å¼€çš„åŠå¾„ï¼ŒåŸºäºå¿ƒè·³æ—¶é—´
                                        // å¿ƒè·³æ•ˆæœï¼šä» 0 å¼€å§‹ï¼Œåœ¨ waveDuration å†…å±•å¼€åˆ°æœ€å¤§åŠå¾„
                                        float maxRadius = 10.0;
                                        float s = smoothstep(0.0, waveDuration, timeSinceBeat) * maxRadius;
                                        
                                        // l: ç²’å­åˆ°ä¸­å¿ƒçš„å¾„å‘è·ç¦»ï¼ˆXZ å¹³é¢ï¼‰
                                        float l = length(localPos.xz);
                                        
                                        // border: æ³¢æµªå‰æ²¿çš„è·ç¦»
                                        float border = abs(s - l - 0.5);
                                        
                                        // åº”ç”¨å¾„å‘ç¼©æ”¾ï¼ˆç±»ä¼¼ Magic æ•ˆæœï¼‰
                                        localPos *= 1.0 - 0.2 * exp(-20.0 * border);
                                        
                                        // åº”ç”¨å™ªå£°æ•ˆæœï¼ˆç±»ä¼¼ Magic æ•ˆæœï¼‰
                                        vec3 noiseOffset = noise(localPos.xyz * 2.0 + vec3(timeSinceBeat * 0.5)) * smoothstep(s - 0.5, s, l + 0.5);
                                        localPos += 0.1 * noiseOffset;
                                        
                                        // åº”ç”¨ç²’å­å°ºå¯¸å˜åŒ–ï¼ˆç±»ä¼¼ Magic æ•ˆæœï¼‰
                                        vec3 finalScales = mix(splatScales, vec3(0.002), smoothstep(s - 0.5, s, l + 0.5));
                                        
                                        // è§’åº¦å±•å¼€æ•ˆæœï¼ˆç±»ä¼¼ Magic æ•ˆæœï¼‰
                                        float at = atan(localPos.x, localPos.z) / 3.1416;
                                        float angleReveal = step(at, timeSinceBeat - 3.1416);
                                        
                                        // åº”ç”¨å‘å…‰æ•ˆæœï¼ˆç±»ä¼¼ Magic æ•ˆæœï¼‰
                                        float glow = exp(-20.0 * border) + exp(-50.0 * abs(timeSinceBeat - at - 3.1416)) * 0.5;
                                        
                                        // ä½¿ç”¨ intensity å‚æ•°è°ƒæ•´æ•ˆæœå¼ºåº¦
                                        float effectIntensity = ${inputs.intensity};
                                        
                                        // æ›´æ–°è¾“å‡º
                                        ${outputs.gsplat}.center = localPos;
                                        ${outputs.gsplat}.scales = mix(splatScales, finalScales, effectIntensity);
                                        ${outputs.gsplat}.rgba = splatColor * angleReveal + vec4(glow * effectIntensity, glow * effectIntensity, glow * effectIntensity, 0.0);
                                    } else {
                                        // å¿ƒè·³æ•ˆæœç»“æŸåï¼Œæ¢å¤åŸå§‹çŠ¶æ€
                                        ${outputs.gsplat}.center = localPos;
                                        ${outputs.gsplat}.scales = splatScales;
                                        ${outputs.gsplat}.rgba = splatColor;
                                    }
                                } else {
                                    // æ²¡æœ‰å¿ƒè·³æ•°æ®æ—¶ï¼Œä¿æŒåŸæ ·
                                    ${outputs.gsplat}.center = localPos;
                                    ${outputs.gsplat}.scales = splatScales;
                                    ${outputs.gsplat}.rgba = splatColor;
                                }
                            }
                            // åº”ç”¨å¿ƒè·³æ³¢æµªæ•ˆæœï¼ˆå¦‚æœå¯ç”¨äº†ç”Ÿç†ä¿¡å·ä¸”ä¸æ˜¯æ— æ•ˆæœæ¨¡å¼ï¼‰
                            else if (heartbeatTime > 0.0) {
                                localPos = heartbeatWave(localPos, t, heartbeatTime);
                            }
                            
                            if (effectType == 1) {
                                // Magic Effect: æ›´æ˜æ˜¾çš„å¾„å‘å±•å¼€æ•ˆæœ
                                float s = smoothstep(0.,10.,t-4.5)*10.;
                                float border = abs(s-l-.5);
                                localPos *= 1.-.2*exp(-20.*border);
                                vec3 finalScales = mix(splatScales,vec3(0.002),smoothstep(s-.5,s,l+.5));
                                ${outputs.gsplat}.center = localPos + .1*noise(localPos.xyz*2.+vec3(t*.5))*smoothstep(s-.5,s,l+.5);
                                ${outputs.gsplat}.scales = finalScales;
                                float at = atan(localPos.x,localPos.z)/3.1416;
                                ${outputs.gsplat}.rgba *= step(at,t-3.1416);
                                float glow = exp(-20.*border) + exp(-50.*abs(t-at-3.1416))*.5;
                                ${outputs.gsplat}.rgba += vec4(glow, glow, glow, 0.0);
                                // ç¡®ä¿æ•ˆæœå¯è§ï¼šå¦‚æœæ—¶é—´å¤ªçŸ­ï¼Œå¼ºåˆ¶æ˜¾ç¤ºéƒ¨åˆ†å†…å®¹
                                if (t < 5.0) {
                                    ${outputs.gsplat}.rgba.a = max(${outputs.gsplat}.rgba.a, 0.3);
                                }
                                
                            } else if (effectType == 2) {
                                // Spread Effect: æ›´æ˜æ˜¾çš„æ‰©æ•£æ•ˆæœ
                                float tt = t*t*.4+.5;
                                localPos.xz *= min(1.,.3+max(0.,tt*.05));
                                ${outputs.gsplat}.center = localPos;
                                ${outputs.gsplat}.scales = max(mix(vec3(0.0),splatScales,min(tt-7.-l*2.5,1.)),mix(vec3(0.0),splatScales*.2,min(tt-1.-l*2.,1.)));
                                ${outputs.gsplat}.rgba = mix(vec4(0.3, 0.3, 0.3, 1.0),splatColor,clamp(tt-l*2.5-3.,0.,1.));
                                
                            } else if (effectType == 3) {
                                // Unroll Effect: æ›´æ˜æ˜¾çš„å±•å¼€æ•ˆæœ
                                localPos.xz *= rot((localPos.y*50.-20.)*exp(-t));
                                ${outputs.gsplat}.center = localPos * (1.-exp(-t)*2.);
                                ${outputs.gsplat}.scales = mix(vec3(0.002),splatScales,smoothstep(.3,.7,t+localPos.y-2.));
                                ${outputs.gsplat}.rgba = splatColor*step(0.,t*.5+localPos.y-.5);
                            } else if (effectType == 4) {
                                // Twister Effect: é¾™å·é£æ•ˆæœ
                                vec4 effectResult = twister(localPos, splatScales, t);
                                ${outputs.gsplat}.center = effectResult.xyz;
                                ${outputs.gsplat}.scales = mix(vec3(.002), splatScales, pow(effectResult.w, 12.));
                                float s = effectResult.w;
                                float spin = -t * 0.3 * (1.0 - s);
                                vec4 spinQ = vec4(0.0, sin(spin*0.5), 0.0, cos(spin*0.5));
                                ${outputs.gsplat}.quaternion = quatQuat(spinQ, ${inputs.gsplat}.quaternion);
                            } else if (effectType == 5) {
                                // Rain Effect: é›¨æ•ˆæœ
                                vec4 effectResult = rain(localPos, splatScales, t);
                                ${outputs.gsplat}.center = effectResult.xyz;
                                ${outputs.gsplat}.scales = mix(vec3(.005), splatScales, pow(effectResult.w, 30.));
                                float spin = -t*.3;
                                vec4 spinQ = vec4(0.0, sin(spin*0.5), 0.0, cos(spin*0.5));
                                ${outputs.gsplat}.quaternion = quatQuat(spinQ, ${inputs.gsplat}.quaternion);
                            }
                            // Shader effects (10-14)
                            else if (effectType == 12) {
                                // Waves Effect with heartbeat rhythm
                                // è®¡ç®—å¿ƒè·³å¾‹åŠ¨å½±å“ï¼šå åŠ æ‰€æœ‰æ´»è·ƒçš„å¿ƒè·³æ•ˆæœï¼Œå½±å“æ³¢çš„é¢‘ç‡å’Œç›¸ä½
                                float frequencyMod = 0.0; // é¢‘ç‡è°ƒåˆ¶
                                float phaseMod = 0.0; // ç›¸ä½è°ƒåˆ¶
                                
                                // å¤„ç†æ¯ä¸ªå¿ƒè·³ï¼ˆæœ€å¤š 3 ä¸ªï¼‰
                                float[] beats = float[](heartbeatTime1, heartbeatTime2, heartbeatTime3);
                                for (int i = 0; i < 3; i++) {
                                    if (beats[i] > 0.0) {
                                        float timeSinceBeat = t - beats[i];
                                        float beatDuration = 2.0; // æ¯æ¬¡å¿ƒè·³æ•ˆæœæŒç»­æ—¶é—´ï¼ˆæ›´é•¿ï¼Œæ›´å¹³æ»‘ï¼‰
                                        if (timeSinceBeat >= 0.0 && timeSinceBeat <= beatDuration) {
                                            // å¹³æ»‘è¿‡æ¸¡ï¼šä½¿ç”¨ smoothstep å®ç°æ›´å¹³æ»‘çš„è¡°å‡
                                            float normalizedTime = timeSinceBeat / beatDuration;
                                            float smoothPulse = (1.0 - smoothstep(0.0, 1.0, normalizedTime));
                                            
                                            // æ¯æ¬¡å¿ƒè·³äº§ç”Ÿä¸åŒçš„å³°å€¼å’Œç›¸ä½åç§»ï¼ˆåŸºäºå¿ƒè·³ç´¢å¼•ï¼‰
                                            float peakVariation = 0.3 + 0.7 * sin(float(i) * 2.094); // 0.3-1.0 ä¹‹é—´å˜åŒ–
                                            float phaseOffset = float(i) * 1.047; // æ¯æ¬¡å¿ƒè·³ç›¸ä½åç§»ä¸åŒ
                                            
                                            // é¢‘ç‡è°ƒåˆ¶ï¼šå¿ƒè·³æ—¶æ³¢é€ŸåŠ å¿«
                                            frequencyMod += smoothPulse * peakVariation * 0.8;
                                            // ç›¸ä½è°ƒåˆ¶ï¼šæ¯æ¬¡å¿ƒè·³äº§ç”Ÿä¸åŒçš„ç›¸ä½åç§»
                                            phaseMod += smoothPulse * sin(phaseOffset) * 2.0;
                                        }
                                    }
                                }
                                // é™åˆ¶å åŠ å€¼
                                frequencyMod = min(frequencyMod, 1.2);
                                
                                // å°†å¿ƒè·³å¾‹åŠ¨åº”ç”¨åˆ°æ•ˆæœï¼šå½±å“æ³¢çš„é¢‘ç‡å’Œç›¸ä½ï¼Œè€Œä¸æ˜¯å¼ºåº¦
                                // å¿ƒè·³æ—¶é¢‘ç‡å¢åŠ ï¼Œäº§ç”Ÿæ›´å¿«çš„æ³¢åŠ¨
                                float modulatedT = t * (1.0 + frequencyMod * 0.6) + phaseMod;
                                vec4 effect = sin3D(localPos, modulatedT);
                                
                                // ä¿æŒåŸå§‹ intensityï¼Œå¿ƒè·³åªå½±å“æ•ˆæœå‚æ•°
                                ${outputs.gsplat}.rgba.rgba = mix(splatColor, splatColor*effect, ${inputs.intensity});
                                vec3 pos = localPos;
                                pos.y += 1.;
                                // å¿ƒè·³å¾‹åŠ¨å½±å“ä½ç½®å˜åŒ–ï¼ˆé€šè¿‡ effect æœ¬èº«ï¼Œè€Œä¸æ˜¯è°ƒæ•´ intensityï¼‰
                                pos *= (1. + effect.x * .05 * ${inputs.intensity});
                                pos.y -= 1.;
                                ${outputs.gsplat}.center = pos;
                            } 
                            else if (effectType == 14) {
                                // Disintegrate Effect with heartbeat rhythm
                                // è®¡ç®—å¿ƒè·³å¾‹åŠ¨å½±å“ï¼šå åŠ æ‰€æœ‰æ´»è·ƒçš„å¿ƒè·³æ•ˆæœï¼Œå½±å“åˆ†è§£çš„é€Ÿåº¦å’Œç›¸ä½
                                float speedMod = 0.0; // é€Ÿåº¦è°ƒåˆ¶
                                float phaseMod = 0.0; // ç›¸ä½è°ƒåˆ¶
                                
                                float[] beats = float[](heartbeatTime1, heartbeatTime2, heartbeatTime3);
                                for (int i = 0; i < 3; i++) {
                                    if (beats[i] > 0.0) {
                                        float timeSinceBeat = t - beats[i];
                                        float beatDuration = 2.0; // æ¯æ¬¡å¿ƒè·³æ•ˆæœæŒç»­æ—¶é—´ï¼ˆæ›´é•¿ï¼Œæ›´å¹³æ»‘ï¼‰
                                        if (timeSinceBeat >= 0.0 && timeSinceBeat <= beatDuration) {
                                            // å¹³æ»‘è¿‡æ¸¡ï¼šä½¿ç”¨ smoothstep å®ç°æ›´å¹³æ»‘çš„è¡°å‡
                                            float normalizedTime = timeSinceBeat / beatDuration;
                                            float smoothPulse = (1.0 - smoothstep(0.0, 1.0, normalizedTime));
                                            
                                            // æ¯æ¬¡å¿ƒè·³äº§ç”Ÿä¸åŒçš„å³°å€¼å’Œç›¸ä½åç§»ï¼ˆåŸºäºå¿ƒè·³ç´¢å¼•ï¼‰
                                            float peakVariation = 0.3 + 0.7 * sin(float(i) * 2.094); // 0.3-1.0 ä¹‹é—´å˜åŒ–
                                            float phaseOffset = float(i) * 1.047; // æ¯æ¬¡å¿ƒè·³ç›¸ä½åç§»ä¸åŒ
                                            
                                            // é€Ÿåº¦è°ƒåˆ¶ï¼šå¿ƒè·³æ—¶åˆ†è§£é€Ÿåº¦åŠ å¿«
                                            speedMod += smoothPulse * peakVariation * 0.6;
                                            // ç›¸ä½è°ƒåˆ¶ï¼šæ¯æ¬¡å¿ƒè·³äº§ç”Ÿä¸åŒçš„ç›¸ä½åç§»
                                            phaseMod += smoothPulse * sin(phaseOffset) * 1.5;
                                        }
                                    }
                                }
                                // é™åˆ¶å åŠ å€¼
                                speedMod = min(speedMod, 1.0);
                                
                                // å°†å¿ƒè·³å¾‹åŠ¨åº”ç”¨åˆ°æ•ˆæœï¼šå½±å“åˆ†è§£çš„é€Ÿåº¦å’Œç›¸ä½ï¼Œè€Œä¸æ˜¯å¼ºåº¦
                                // å¿ƒè·³æ—¶åˆ†è§£é€Ÿåº¦å¢åŠ ï¼Œäº§ç”Ÿä¸åŒçš„å³°å€¼
                                float modulatedT = t * (1.0 + speedMod * 0.5) + phaseMod;
                                // ä¿æŒåŸå§‹ intensityï¼Œå¿ƒè·³åªå½±å“æ•ˆæœå‚æ•°ï¼ˆé€Ÿåº¦ã€ç›¸ä½ï¼‰
                                vec4 e = disintegrate(localPos, modulatedT, ${inputs.intensity});
                                ${outputs.gsplat}.center = e.xyz;
                                ${outputs.gsplat}.scales = mix(vec3(.01, .01, .01), ${inputs.gsplat}.scales, e.w);
                            }
                        `),
                    });

                    // ç¡®ä¿ animateT å·²åˆå§‹åŒ–
                    if (!state.animateT) {
                        console.warn('animateT æœªåˆå§‹åŒ–ï¼Œè·³è¿‡æ•ˆæœ');
                        return { gsplat };
                    }
                    
                    // è®¡ç®—å¿ƒè·³æ—¶é—´æ•°ç»„ï¼ˆç›¸å¯¹äº effectStartTimeï¼‰
                    // ä¿ç•™æœ€è¿‘å‡ æ¬¡å¿ƒè·³ï¼Œç”¨äºå åŠ æ•ˆæœ
                    let heartbeatTimes = [];
                    if (state.audiuno.usePhysiological && state.audiuno.heartbeatTimes && state.audiuno.heartbeatTimes.length > 0) {
                        // åªä¿ç•™æœ€è¿‘ 3 æ¬¡å¿ƒè·³ï¼ˆç”¨äºå åŠ æ•ˆæœï¼‰
                        const recentBeats = state.audiuno.heartbeatTimes.slice(-3);
                        heartbeatTimes = recentBeats.map(beatTime => beatTime - state.effectStartTime).filter(t => t >= 0);
                    } else if (state.audiuno.usePhysiological && state.audiuno.lastHeartbeatTime > 0) {
                        // å¦‚æœæ²¡æœ‰å†å²è®°å½•ï¼Œä½¿ç”¨æœ€è¿‘ä¸€æ¬¡å¿ƒè·³
                        heartbeatTimes = [state.audiuno.lastHeartbeatTime - state.effectStartTime].filter(t => t >= 0);
                    }
                    
                    // ä¸ºäº†å…¼å®¹æ€§ï¼Œä¹Ÿä¼ é€’æœ€è¿‘ä¸€æ¬¡å¿ƒè·³æ—¶é—´
                    // heartbeatTimes æ•°ç»„ï¼šæœ€æ–°çš„åœ¨æœ€åï¼Œæ‰€ä»¥ heartbeatTime1 åº”è¯¥æ˜¯æœ€æ–°çš„
                    let heartbeatTime = heartbeatTimes.length > 0 ? heartbeatTimes[heartbeatTimes.length - 1] : -1.0;
                    // åè½¬é¡ºåºï¼Œè®© heartbeatTime1 æ˜¯æœ€æ–°çš„å¿ƒè·³
                    let heartbeatTime1 = heartbeatTimes.length > 0 ? heartbeatTimes[heartbeatTimes.length - 1] : -1.0;
                    let heartbeatTime2 = heartbeatTimes.length > 1 ? heartbeatTimes[heartbeatTimes.length - 2] : -1.0;
                    let heartbeatTime3 = heartbeatTimes.length > 2 ? heartbeatTimes[heartbeatTimes.length - 3] : -1.0;
                    
                    console.log('å¿ƒè·³æ—¶é—´:', { heartbeatTime, heartbeatTime1, heartbeatTime2, heartbeatTime3, times: heartbeatTimes, length: heartbeatTimes.length });
                    
                    gsplat = d.apply({ 
                        gsplat, 
                        t: state.animateT,
                        effectType: dyno.dynoInt(effectInt),
                        intensity: dyno.dynoFloat(state.effectParams.intensity || 0.8),
                        heartbeatTime: dyno.dynoFloat(heartbeatTime),
                        heartbeatTime1: dyno.dynoFloat(heartbeatTime1),
                        heartbeatTime2: dyno.dynoFloat(heartbeatTime2),
                        heartbeatTime3: dyno.dynoFloat(heartbeatTime3)
                    }).gsplat;
                    
                    return { gsplat };
                }
            );

            splatMesh.updateGenerator();
        }

        // 3. æ ¸å¿ƒ 3D æ¸²æŸ“ - ä½¿ç”¨ Spark åº“
        // æ¸…ç† WebGL èµ„æºçš„è¾…åŠ©å‡½æ•°
        function cleanupWebGL() {
            console.log('å¼€å§‹æ¸…ç† WebGL èµ„æº...');
            
            // åœæ­¢åŠ¨ç”»å¾ªç¯
            if (state.animationId) {
                cancelAnimationFrame(state.animationId);
                state.animationId = null;
            }
            
            // æ¸…ç†åœºæ™¯ä¸­çš„å¯¹è±¡
            if (state.scene) {
                while (state.scene.children.length > 0) {
                    const child = state.scene.children[0];
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                if (mat.map) mat.map.dispose();
                                mat.dispose();
                            });
                        } else {
                            if (child.material.map) child.material.map.dispose();
                            child.material.dispose();
                        }
                    }
                    state.scene.remove(child);
                }
                state.scene = null;
            }
            
            // æ¸…ç†æ¸²æŸ“å™¨
            if (state.renderer) {
                const container = document.getElementById('splat-viewer');
                const canvas = state.renderer.domElement;
                
                // å®‰å…¨åœ°ç§»é™¤ canvas
                if (container && canvas && canvas.parentNode === container) {
                    try {
                        container.removeChild(canvas);
                    } catch (e) {
                        console.warn('ç§»é™¤ canvas å¤±è´¥:', e);
                    }
                }
                
                // å¼ºåˆ¶æ¸…ç† WebGL ä¸Šä¸‹æ–‡
                try {
                    if (state.renderer && typeof state.renderer.getContext === 'function') {
                        const gl = state.renderer.getContext();
                        if (gl && !gl.isContextLost()) {
                            const loseContext = gl.getExtension('WEBGL_lose_context');
                            if (loseContext) {
                                loseContext.loseContext();
                            }
                        }
                    }
                } catch (e) {
                    console.warn('æ¸…ç† WebGL ä¸Šä¸‹æ–‡å¤±è´¥:', e);
                }
                
                // é‡Šæ”¾æ¸²æŸ“å™¨èµ„æº
                try {
                    state.renderer.dispose();
                } catch (e) {
                    console.warn('é‡Šæ”¾æ¸²æŸ“å™¨å¤±è´¥:', e);
                }
                
                state.renderer = null;
            }
            
            // æ¸…ç†æ§åˆ¶å™¨
            if (state.controls) {
                try {
                    if (typeof state.controls.dispose === 'function') {
                        state.controls.dispose();
                    }
                } catch (e) {
                    console.warn('æ¸…ç†æ§åˆ¶å™¨å¤±è´¥:', e);
                }
                state.controls = null;
            }
            
            // æ¸…ç†å…¶ä»–èµ„æº
            state.splatMesh = null;
            state.camera = null;
            state.animateT = null;
            
            console.log('WebGL èµ„æºæ¸…ç†å®Œæˆ');
        }

        document.getElementById('enter-btn').onclick = async () => {
            // é˜²æ­¢é‡å¤ç‚¹å‡»
            if (state.isInitializing) {
                console.log('æ­£åœ¨åˆå§‹åŒ–ä¸­ï¼Œè¯·ç¨å€™...');
                return;
            }
            
            const container = document.getElementById('splat-viewer');
            const loader = document.getElementById('loading-overlay');
            
            // è®¾ç½®åˆå§‹åŒ–æ ‡å¿—
            state.isInitializing = true;
            
            try {
            container.style.display = 'block';
                loader.style.display = 'flex';
                loader.innerText = 'ğŸ”„ æ­£åœ¨åˆå§‹åŒ–...';

                // æ‰“å¼€ 3D è§†å›¾æ—¶éšè—åœ°å›¾å’Œä¸Šå±‚ UIï¼Œé¿å…æŒ¡ä½æ¨¡å‹äº¤äº’
                document.getElementById('ui-layer').style.display = 'none';
                document.getElementById('map-background').style.display = 'none';
                // ç¡®ä¿ä»»åŠ¡å¼¹çª—å…³é—­ï¼Œé¿å…ç°è‰²è’™å±‚æ®‹ç•™
                const modal = document.getElementById('modal-overlay');
                if (modal) modal.style.display = 'none';
                // æ˜¾ç¤ºèŠå¤©çª—å£ï¼ˆç”± showChatUI æ§åˆ¶å†…éƒ¨å†…å®¹ï¼‰
                showChatUI();
                
                // æ˜¾ç¤ºæ•ˆæœæ§åˆ¶é¢æ¿
                const effectControls = document.getElementById('effect-controls');
                if (effectControls) {
                    effectControls.style.display = 'block';
                    // è®¾ç½®å½“å‰é€‰æ‹©çš„æ•ˆæœ
                    const effectSelect = document.getElementById('effect-select');
                    if (effectSelect) {
                        effectSelect.value = state.effectParams.effect;
                    }
                    // æ˜¾ç¤º/éšè—å¼ºåº¦æ§åˆ¶ï¼ˆä»… shader effects éœ€è¦ï¼‰
                    const intensityControl = document.getElementById('intensity-control');
                    const shaderEffects = ['Waves', 'Disintegrate'];
                    const isShaderEffect = shaderEffects.includes(state.effectParams.effect);
                    if (intensityControl) {
                        intensityControl.style.display = isShaderEffect ? 'block' : 'none';
                    }
                    // è®¾ç½®å¼ºåº¦æ»‘å—çš„å€¼
                    const intensitySlider = document.getElementById('intensity-slider');
                    const intensityValue = document.getElementById('intensity-value');
                    if (intensitySlider && intensityValue) {
                        intensitySlider.value = state.effectParams.intensity || 0.8;
                        intensityValue.textContent = (state.effectParams.intensity || 0.8).toFixed(2);
                    }
                }
                
                // æ˜¾ç¤ºè¯­è¨€åˆ‡æ¢æŒ‰é’®
                const viewLangToggle = document.getElementById('view-lang-toggle');
                if (viewLangToggle) {
                    viewLangToggle.style.display = 'block';
                    viewLangToggle.innerText = state.lang === 'cn' ? 'EN / ä¸­' : 'ä¸­ / EN';
                }

                // æ¸…ç†ä¹‹å‰çš„åœºæ™¯ï¼ˆä½¿ç”¨æ”¹è¿›çš„æ¸…ç†å‡½æ•°ï¼‰
                cleanupWebGL();
                
                // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œç¡®ä¿æ¸…ç†å®Œæˆ
                await new Promise(resolve => setTimeout(resolve, 100));

                // åˆ›å»ºåœºæ™¯
                state.scene = new THREE.Scene();
                state.scene.background = new THREE.Color(0x1a1a1a);

                // åˆ›å»ºç›¸æœº
                state.camera = new THREE.PerspectiveCamera(
                    60,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                state.camera.position.set(0, 0, 5);

                // åˆ›å»ºæ¸²æŸ“å™¨ï¼ˆæ·»åŠ é”™è¯¯å¤„ç†å’Œé™çº§æ”¯æŒï¼‰
                let rendererOptions = { 
                    antialias: true,
                    powerPreference: "high-performance",
                    failIfMajorPerformanceCaveat: false
                };
                
                try {
                    state.renderer = new THREE.WebGLRenderer(rendererOptions);
                } catch (e) {
                    console.warn('WebGL2 åˆ›å»ºå¤±è´¥ï¼Œå°è¯• WebGL1:', e);
                    // å¦‚æœ WebGL2 å¤±è´¥ï¼Œå°è¯• WebGL1
                    rendererOptions = { 
                        antialias: false,
                        powerPreference: "default"
                    };
                    try {
                        state.renderer = new THREE.WebGLRenderer(rendererOptions);
                    } catch (e2) {
                        throw new Error('æ— æ³•åˆ›å»º WebGL ä¸Šä¸‹æ–‡ã€‚è¯·æ£€æŸ¥æµè§ˆå™¨å’Œæ˜¾å¡é©±åŠ¨æ˜¯å¦æ”¯æŒ WebGLã€‚');
                    }
                }
                
                // æ£€æŸ¥æ¸²æŸ“å™¨æ˜¯å¦æˆåŠŸåˆ›å»º
                if (!state.renderer || !state.renderer.getContext()) {
                    throw new Error('WebGL ä¸Šä¸‹æ–‡åˆ›å»ºå¤±è´¥');
                }
                state.renderer.setSize(window.innerWidth, window.innerHeight);
                state.renderer.setPixelRatio(window.devicePixelRatio);
                state.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                state.renderer.toneMappingExposure = 1.2;
                container.appendChild(state.renderer.domElement);

                // åˆ›å»ºæ§åˆ¶å™¨ï¼ˆä½¿ç”¨ SparkControlsï¼‰
                state.controls = new SparkControls({ canvas: state.renderer.domElement });

                // åŠ è½½ splat æ¨¡å‹
                const url = `https://huggingface.co/datasets/${REPO_ID}/resolve/main/${state.currentLoc.splatPath}`;
                loader.innerText = 'ğŸ“¦ æ­£åœ¨è§£ææ¨¡å‹æ–‡ä»¶...';
                
                // åˆ›å»º SplatMesh
                state.splatMesh = new SplatMesh({ url: url });
                
                // æ·»åŠ åˆ°åœºæ™¯
                state.scene.add(state.splatMesh);
                
                // ç­‰å¾…æ¨¡å‹åŠ è½½å®Œæˆ
                loader.innerText = 'âœ¨ ç­‰å¾…æ¨¡å‹åŠ è½½...';
                await state.splatMesh.loaded;
                loader.innerText = 'âœ¨ æ¨¡å‹åŠ è½½å®Œæˆï¼';
                
                // åˆå§‹åŒ–åŠ¨ç”»æ—¶é—´ï¼ˆå¿…é¡»åœ¨æ¨¡å‹åŠ è½½åï¼‰
                state.animateT = dyno.dynoFloat(0);
                state.baseTime = 0;
                state.effectStartTime = 0; // æ•ˆæœå¼€å§‹æ—¶é—´ï¼Œç”¨äºé‡ç½®æ•ˆæœ
                
                // è®¾ç½®è§†è§‰æ•ˆæœï¼ˆå¿…é¡»åœ¨ animateT åˆå§‹åŒ–åï¼‰
                console.log('è®¾ç½®è§†è§‰æ•ˆæœï¼ŒeffectType:', state.effectParams.effect, 'animateT:', state.animateT);
                setupSplatModifier(state.splatMesh, state.effectParams.effect);
                console.log('è§†è§‰æ•ˆæœè®¾ç½®å®Œæˆ');
                
                // å±…ä¸­æ¨¡å‹å¹¶ä¿®å¤å€’ç½®é—®é¢˜
                console.log('å¼€å§‹å±…ä¸­æ¨¡å‹...');
                
                // å…ˆä¿®å¤ä¸Šä¸‹é¢ å€’ï¼šç»•Xè½´æ—‹è½¬180åº¦
                state.splatMesh.rotation.x = Math.PI;
                
                // è®¡ç®—è¾¹ç•Œæ¡†ï¼ˆè€ƒè™‘æ—‹è½¬åï¼‰
                const box = new THREE.Box3().setFromObject(state.splatMesh);
                console.log('æ¨¡å‹è¾¹ç•Œæ¡†:', box.min, box.max);
                
                if (box.isEmpty()) {
                    console.warn('è¾¹ç•Œæ¡†ä¸ºç©ºï¼Œä½¿ç”¨é»˜è®¤ä½ç½®');
                    state.modelCenter = new THREE.Vector3(0, 0, 0);
                    state.camera.position.set(0, 0, 5);
                    state.camera.lookAt(state.modelCenter);
                } else {
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    console.log('æ¨¡å‹ä¸­å¿ƒ:', center, 'å°ºå¯¸:', size);
                    
                    // å°†æ¨¡å‹ç§»åŠ¨åˆ°åŸç‚¹ï¼ˆå±…ä¸­ï¼‰
                    state.splatMesh.position.sub(center);
                    
                    // ä¿å­˜æ¨¡å‹ä¸­å¿ƒç‚¹ï¼ˆç”¨äºç›¸æœºçœ‹å‘å’Œæ—‹è½¬ï¼‰
                    state.modelCenter = new THREE.Vector3(0, 0, 0);
                    
                    // é‡æ–°è®¡ç®—è¾¹ç•Œæ¡†ç¡®è®¤å±…ä¸­
                    const box2 = new THREE.Box3().setFromObject(state.splatMesh);
                    const center2 = box2.getCenter(new THREE.Vector3());
                    console.log('å±…ä¸­åçš„ä¸­å¿ƒ:', center2);
                    
                    // è°ƒæ•´ç›¸æœºä½ç½®ï¼Œç¡®ä¿æ¨¡å‹åœ¨è§†é‡ä¸­å¿ƒ
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const cameraDistance = maxDim * 2.5;
                    state.camera.position.set(0, 0, cameraDistance);
                    state.camera.lookAt(state.modelCenter);
                    console.log('ç›¸æœºä½ç½®:', state.camera.position, 'è·ç¦»:', cameraDistance);
                }
                
                // éšè—åŠ è½½æç¤º
                loader.style.display = 'none';
                loader.style.pointerEvents = 'none';

                // ç¡®ä¿åœºæ™¯ä¸­æœ‰å†…å®¹
                console.log('åœºæ™¯å¯¹è±¡æ•°é‡:', state.scene.children.length);
                console.log('SplatMesh:', state.splatMesh);
                console.log('ç›¸æœºä½ç½®:', state.camera.position);
                console.log('ç›¸æœºæœå‘:', state.camera.rotation);

                // æ¸²æŸ“å¾ªç¯
                state.lastTime = performance.now();
                function animate() {
                    const currentTime = performance.now();
                    const deltaTime = (currentTime - state.lastTime) / 1000; // è½¬æ¢ä¸ºç§’
                    state.lastTime = currentTime;
                    state.baseTime += deltaTime;
                    
                    // å¦‚æœä½¿ç”¨ç”Ÿç†ä¿¡å·ï¼Œé¢„æµ‹å¿ƒè·³äº‹ä»¶
                    if (state.audiuno.usePhysiological) {
                        predictHeartbeat();
                    }
                    
                    if (state.animateT) {
                        // ä½¿ç”¨ç›¸å¯¹äºæ•ˆæœå¼€å§‹æ—¶é—´çš„æ—¶é—´
                        let effectTime = state.baseTime - state.effectStartTime;
                        
                        // å¦‚æœä½¿ç”¨ç”Ÿç†ä¿¡å·ï¼Œæ ¹æ®å¿ƒç‡è°ƒæ•´åŠ¨ç”»é€Ÿåº¦
                        if (state.audiuno.usePhysiological && state.audiuno.heartRate > 0) {
                            // å¿ƒç‡æ˜ å°„åˆ°é€Ÿåº¦å€æ•°ï¼š60 BPM -> 0.8x, 100 BPM -> 1.2x
                            const speedMultiplier = 0.8 + ((state.audiuno.heartRate - 60) / 40) * 0.4;
                            effectTime *= speedMultiplier;
                        }
                        
                        state.animateT.value = effectTime;
                    }
                    
                    // æ›´æ–° splat æ¸²æŸ“
                    if (state.splatMesh) {
                        state.splatMesh.updateVersion();
                    }
                    
                    // æ›´æ–°æ§åˆ¶å™¨å’Œæ¸²æŸ“
                    if (state.controls && state.camera) {
                        state.controls.update(state.camera);
                    }
                    if (state.renderer && state.scene && state.camera) {
                        state.renderer.render(state.scene, state.camera);
                    }
                    
                    state.animationId = requestAnimationFrame(animate);
                }
                animate();

                // å¤„ç†çª—å£å¤§å°å˜åŒ–
                const handleResize = () => {
                    if (state.camera && state.renderer) {
                        state.camera.aspect = window.innerWidth / window.innerHeight;
                        state.camera.updateProjectionMatrix();
                        state.renderer.setSize(window.innerWidth, window.innerHeight);
                    }
                };
                window.addEventListener('resize', handleResize);
                state.resizeHandler = handleResize; // ä¿å­˜å¼•ç”¨ä»¥ä¾¿æ¸…ç†
                
                // éšè—åŠ è½½æç¤º
                loader.style.display = 'none';
                
                // åˆå§‹åŒ–å®Œæˆï¼Œé‡ç½®æ ‡å¿—
                state.isInitializing = false;

            } catch (err) {
                console.error('åŠ è½½æ¨¡å‹å¤±è´¥:', err);
                loader.innerText = 'âŒ åŠ è½½å¤±è´¥: ' + (err.message || 'è¯·æ£€æŸ¥æ¨¡å‹æ–‡ä»¶');
                loader.style.display = 'flex';
                setTimeout(() => {
                    loader.style.display = 'none';
                }, 3000);
                
                // æ¸…ç†å·²åˆ›å»ºçš„èµ„æº
                cleanupWebGL();
                
                // åˆå§‹åŒ–å¤±è´¥ï¼Œé‡ç½®æ ‡å¿—
                state.isInitializing = false;
            }
        };

        // 4. ç‰©ç†åˆ é™¤é€»è¾‘ [web:31][web:79][web:83]
        document.getElementById('del-btn').onclick = async () => {
            const token = prompt("è¯·è¾“å…¥ HF Write Token ä»¥ç¡®è®¤åˆ é™¤ï¼š");
            if (!token || !confirm("æ°¸ä¹…åˆ é™¤è¯¥æ¨¡å‹åŠç…§ç‰‡ï¼Ÿ")) return;

            const operations = [
                { operation: "delete", path: state.currentLoc.photoPath },
                { operation: "addOrUpdate", path: "locations.json", content: new Blob([JSON.stringify(state.locations.filter(l => l.id !== state.currentLoc.id), null, 2)], {type:"application/json"}) }
            ];
            if (state.currentLoc.splatPath) operations.push({ operation: "delete", path: state.currentLoc.splatPath });

            try {
                await commit({ credentials: { accessToken: token }, repo: { type: "dataset", name: REPO_ID }, title: "Delete location", operations });
                location.reload();
            } catch (e) { alert("åˆ é™¤å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™ã€‚"); }
        };

        // ä¿å­˜ DeepL Key
        document.getElementById('deepl-key').value = state.deeplKey;
        document.getElementById('deepl-key').addEventListener('change', (e) => {
            state.deeplKey = e.target.value.trim();
            localStorage.setItem('DEEPL_KEY', state.deeplKey);
        });
        
        // è‡ªåŠ¨ç¿»è¯‘ï¼šå½“è¾“å…¥ä¸­æ–‡æè¿°æ—¶ï¼Œè‡ªåŠ¨ç¿»è¯‘ä¸ºè‹±æ–‡ï¼ˆä¿å­˜åˆ° state ä¸­ï¼‰
        let autoTranslatedDescEn = '';
        document.getElementById('desc-input').addEventListener('input', async (e) => {
            const descCn = e.target.value.trim();
            if (descCn && state.deeplKey) {
                autoTranslatedDescEn = await translateWithDeepL(descCn);
                console.log('âœ… æè¿°å·²è‡ªåŠ¨ç¿»è¯‘ä¸ºè‹±æ–‡');
            } else {
                autoTranslatedDescEn = '';
            }
        });
        
        // è‡ªåŠ¨ç¿»è¯‘ï¼šå½“è¾“å…¥ä¸­æ–‡åç§°æ—¶ï¼Œè‡ªåŠ¨ç¿»è¯‘ä¸ºè‹±æ–‡
        document.getElementById('loc-name').addEventListener('input', async (e) => {
            const nameCn = e.target.value.trim();
            const nameEnInput = document.getElementById('loc-name-en');
            if (nameCn && state.deeplKey && !nameEnInput.value.trim()) {
                nameEnInput.placeholder = 'æ­£åœ¨ç¿»è¯‘...';
                const translated = await translateWithDeepL(nameCn);
                nameEnInput.value = translated;
                nameEnInput.placeholder = 'Location Name (Englishï¼Œç•™ç©ºå°†è‡ªåŠ¨ç¿»è¯‘)';
            }
        });
        
        // 5. ä¸Šä¼ ä»»åŠ¡é€»è¾‘
        document.getElementById('submit-btn').onclick = async () => {
            const token = document.getElementById('hf-token').value.trim();
            const file = document.getElementById('photo-input').files[0];
            const name = document.getElementById('loc-name').value.trim();
            let nameEn = document.getElementById('loc-name-en').value.trim();
            const desc = document.getElementById('desc-input').value.trim();
            
            if (!token || !file || !state.selectedCoords || !name) {
                alert("è¯·å¡«å†™å®Œæ•´ä¿¡æ¯ï¼šTokenã€ç…§ç‰‡ã€åæ ‡å’Œä¸­æ–‡åç§°");
                return;
            }
            
            // å¦‚æœæ²¡æœ‰è‹±æ–‡åç§°ï¼Œå°è¯•ç¿»è¯‘
            if (!nameEn && state.deeplKey) {
                nameEn = await translateWithDeepL(name);
            }
            if (!nameEn) nameEn = name;
            
            // è·å–è‡ªåŠ¨ç¿»è¯‘çš„è‹±æ–‡æè¿°ï¼Œå¦‚æœæ²¡æœ‰åˆ™ç¿»è¯‘
            let descEn = autoTranslatedDescEn;
            if (!descEn && desc && state.deeplKey) {
                descEn = await translateWithDeepL(desc);
            }
            if (!descEn) descEn = desc || "";

            const ts = Date.now();
            const safeName = file.name.replace(/[^a-z0-9.]/gi, '_');
            const photoPath = `inputs/${ts}_${safeName}`;
            
            const newLoc = {
                id: ts,
                lat: state.selectedCoords.lat,
                lon: state.selectedCoords.lng,
                name: name,
                name_en: nameEn,
                desc: desc || "",
                desc_en: descEn,
                photoPath: photoPath,
                splatPath: "",
                status: "processing"
            };
            
            const newLocations = [...state.locations, newLoc];

            try {
                await commit({
                    credentials: { accessToken: token },
                    repo: { type: "dataset", name: REPO_ID },
                    title: `Upload task ${ts}`,
                    operations: [
                        { operation: "addOrUpdate", path: photoPath, content: file },
                        { operation: "addOrUpdate", path: "locations.json", content: new Blob([JSON.stringify(newLocations, null, 2)], {type:"application/json"}) }
                    ]
                });
                alert("ä»»åŠ¡ä¸Šä¼ æˆåŠŸï¼");
                document.getElementById('modal-overlay').style.display = 'none';
                // æ¸…ç©ºè¡¨å•ï¼ˆä¿ç•™ DeepL Keyï¼‰
                document.getElementById('hf-token').value = '';
                document.getElementById('loc-name').value = '';
                document.getElementById('loc-name-en').value = '';
                document.getElementById('lat-lon').value = '';
                document.getElementById('photo-input').value = '';
                document.getElementById('desc-input').value = '';
                autoTranslatedDescEn = '';
                state.selectedCoords = null;
                loadLocations();
            } catch (e) {
                alert("ä¸Šä¼ å¤±è´¥ï¼š" + (e.message || e));
            }
        };

        // 6. å…¶ä»–äº¤äº’é€»è¾‘ (æ‹¾å–ã€ä¸Šä¼ ã€AI)
        document.getElementById('upload-btn').onclick = () => document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('pick-btn').onclick = () => { document.getElementById('modal-overlay').style.display = 'none'; state.isPicking = true; };
        map.on('click', (e) => {
            if (state.isPicking) {
                state.selectedCoords = e.latlng;
                document.getElementById('lat-lon').value = `${e.latlng.lat.toFixed(4)}, ${e.latlng.lng.toFixed(4)}`;
                state.isPicking = false;
                document.getElementById('modal-overlay').style.display = 'flex';
            }
        });

        document.getElementById('close-splat').onclick = () => {
            document.getElementById('splat-viewer').style.display = 'none';
            // å…³é—­ 3D è§†å›¾æ—¶æ¢å¤åœ°å›¾å’Œ UI
            document.getElementById('ui-layer').style.display = 'block';
            document.getElementById('map-background').style.display = 'block';
            // éšè—æ•ˆæœæ§åˆ¶é¢æ¿å’Œæ—‹è½¬æŒ‰é’®
            const effectControls = document.getElementById('effect-controls');
            if (effectControls) {
                effectControls.style.display = 'none';
            }
            // æ¸…ç†èµ„æº
            if (state.renderer) {
                state.renderer.setAnimationLoop(null);
            }
            if (state.animationId) {
                cancelAnimationFrame(state.animationId);
                state.animationId = null;
            }
            state.lastTime = undefined;
            if (state.resizeHandler) {
                window.removeEventListener('resize', state.resizeHandler);
                state.resizeHandler = null;
            }
            if (state.controls) {
                state.controls.dispose();
                state.controls = null;
            }
            if (state.renderer) {
                const container = document.getElementById('splat-viewer');
                if (state.renderer.domElement && container.contains(state.renderer.domElement)) {
                    container.removeChild(state.renderer.domElement);
                }
                state.renderer.dispose();
                state.renderer = null;
            }
            if (state.splatMesh) {
                if (state.scene) {
                    state.scene.remove(state.splatMesh);
                }
                // å¦‚æœ SplatMesh æœ‰ dispose æ–¹æ³•ï¼Œè°ƒç”¨å®ƒ
                if (state.splatMesh.dispose) {
                    state.splatMesh.dispose();
                }
                state.splatMesh = null;
            }
            if (state.scene) {
                state.scene.clear();
                state.scene = null;
            }
            state.camera = null;
        };

        document.getElementById('save-key-btn').onclick = () => {
            const key = document.getElementById('user-gemini-key').value.trim();
            if (key) {
                ACTIVE_GEMINI_KEY = key;
                localStorage.setItem('MY_GEMINI_KEY', key);
                document.getElementById('gemini-config-ui').style.display = 'none';
                document.getElementById('chat-main-ui').style.display = 'flex';
                // æ ¹æ®å½“å‰è¯­è¨€è®¾ç½®æ¬¢è¿æ¶ˆæ¯
                if (state.lang === 'cn') {
                    addChatMessage('agent', 'å¥½å‘€ï¼Œæˆ‘å·²ç»è¿ä¸Š Gemini äº†ï¼Œéšä¾¿é—®æˆ‘å…³äºè¿™ä¸ªåœºæ™¯çš„ä»»ä½•é—®é¢˜ï½');
                } else {
                    addChatMessage('agent', 'Great! I\'ve connected to Gemini. Feel free to ask me anything about this scene!');
                }
            }
        };

        // èŠå¤©å‘é€æŒ‰é’®å’Œå›è½¦é”®
        document.getElementById('chat-send').onclick = () => { handleChat(); };
        
        // è·å–èŠå¤©è¾“å…¥æ¡†
        const chatInput = document.getElementById('chat-input');
        
        // å¤„ç†é”®ç›˜äº‹ä»¶ï¼šé˜»æ­¢ä¸ 3D viewer å¿«æ·é”®å†²çª
        chatInput.addEventListener('keydown', (e) => {
            // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé˜²æ­¢è§¦å‘ 3D viewer çš„å¿«æ·é”®
            e.stopPropagation();
            
            if (e.key === 'Enter') {
                e.preventDefault();
                handleChat();
            }
        });
        
        // å¤„ç†é”®ç›˜äº‹ä»¶ï¼šé˜»æ­¢æ‰€æœ‰é”®ç›˜äº‹ä»¶å†’æ³¡
        chatInput.addEventListener('keyup', (e) => {
            e.stopPropagation();
        });
        
        // å¤„ç†è¾“å…¥äº‹ä»¶ï¼šé˜»æ­¢è¾“å…¥äº‹ä»¶å†’æ³¡
        chatInput.addEventListener('input', (e) => {
            e.stopPropagation();
        });
        
        // å½“è¾“å…¥æ¡†è·å¾—ç„¦ç‚¹æ—¶ï¼Œç¦ç”¨ 3D viewer çš„æ§åˆ¶å™¨
        chatInput.addEventListener('focus', () => {
            if (state.controls) {
                // ä¸´æ—¶ç¦ç”¨æ§åˆ¶å™¨ï¼ˆå¦‚æœæ”¯æŒï¼‰
                if (typeof state.controls.enabled !== 'undefined') {
                    state.controls.enabled = false;
                }
            }
            // é˜»æ­¢æ‰€æœ‰é”®ç›˜äº‹ä»¶ä¼ æ’­åˆ° document
            document.addEventListener('keydown', preventViewerShortcuts, true);
            document.addEventListener('keyup', preventViewerShortcuts, true);
        });
        
        // å½“è¾“å…¥æ¡†å¤±å»ç„¦ç‚¹æ—¶ï¼Œé‡æ–°å¯ç”¨ 3D viewer çš„æ§åˆ¶å™¨
        chatInput.addEventListener('blur', () => {
            if (state.controls) {
                // é‡æ–°å¯ç”¨æ§åˆ¶å™¨
                if (typeof state.controls.enabled !== 'undefined') {
                    state.controls.enabled = true;
                }
            }
            // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
            document.removeEventListener('keydown', preventViewerShortcuts, true);
            document.removeEventListener('keyup', preventViewerShortcuts, true);
        });
        
        // é˜»æ­¢ 3D viewer å¿«æ·é”®çš„å‡½æ•°
        function preventViewerShortcuts(e) {
            // å¦‚æœäº‹ä»¶æ¥è‡ªèŠå¤©è¾“å…¥æ¡†æˆ–å…¶çˆ¶å…ƒç´ ï¼Œé˜»æ­¢ä¼ æ’­
            const target = e.target;
            if (target && (target.id === 'chat-input' || target.closest('#chat-window'))) {
                e.stopPropagation();
            }
        }

        // è¯­è¨€åˆ‡æ¢æŒ‰é’®
        document.getElementById('lang-toggle').onclick = () => {
            state.lang = state.lang === 'cn' ? 'en' : 'cn';
            updateLangUI();
        };

        // æ•ˆæœé€‰æ‹©å™¨
        document.getElementById('effect-select').addEventListener('change', (e) => {
            const effect = e.target.value;
            state.effectParams.effect = effect;
            console.log('åˆ‡æ¢è§†è§‰æ•ˆæœ:', effect);
            
            // æ˜¾ç¤º/éšè—å¼ºåº¦æ§åˆ¶ï¼ˆä»… shader effects éœ€è¦ï¼‰
            const intensityControl = document.getElementById('intensity-control');
            const shaderEffects = ['Waves', 'Disintegrate'];
            const isShaderEffect = shaderEffects.includes(effect);
            if (intensityControl) {
                intensityControl.style.display = isShaderEffect ? 'block' : 'none';
            }
            
            if (state.splatMesh) {
                // ç¡®ä¿ animateT å·²åˆå§‹åŒ–
                if (!state.animateT) {
                    console.warn('åˆ‡æ¢æ•ˆæœæ—¶ animateT æœªåˆå§‹åŒ–ï¼Œé‡æ–°åˆå§‹åŒ–');
                    state.animateT = dyno.dynoFloat(0);
                }
                // é‡ç½®æ•ˆæœå¼€å§‹æ—¶é—´ï¼Œè®©æ•ˆæœé‡æ–°å¼€å§‹
                state.effectStartTime = state.baseTime;
                setupSplatModifier(state.splatMesh, effect);
                // å¼ºåˆ¶æ›´æ–°æ¸²æŸ“
                if (state.splatMesh.updateVersion) {
                    state.splatMesh.updateVersion();
                }
            } else {
                console.warn('åˆ‡æ¢æ•ˆæœæ—¶ splatMesh ä¸å­˜åœ¨');
            }
        });

        // å¼ºåº¦æ»‘å—æ§åˆ¶
        const intensitySlider = document.getElementById('intensity-slider');
        const intensityValue = document.getElementById('intensity-value');
        if (intensitySlider && intensityValue) {
            intensitySlider.addEventListener('input', (e) => {
                state.effectParams.intensity = parseFloat(e.target.value);
                intensityValue.textContent = state.effectParams.intensity.toFixed(2);
                if (state.splatMesh && state.effectParams.effect !== 'None') {
                    setupSplatModifier(state.splatMesh, state.effectParams.effect);
                    if (state.splatMesh.updateVersion) {
                        state.splatMesh.updateVersion();
                    }
                }
            });
        }

        // æ—¶é—´é‡ç½®æŒ‰é’®
        document.getElementById('reset-time-btn').addEventListener('click', () => {
            if (state.splatMesh && state.effectParams.effect !== 'None') {
                // é‡ç½®æ•ˆæœå¼€å§‹æ—¶é—´ï¼Œè®©æ•ˆæœé‡æ–°å¼€å§‹
                state.effectStartTime = state.baseTime;
                console.log('æ•ˆæœæ—¶é—´å·²é‡ç½®ï¼Œå½“å‰ baseTime:', state.baseTime);
            }
        });

        // 3Dè§†å›¾è¯­è¨€åˆ‡æ¢æŒ‰é’®
        document.getElementById('view-lang-toggle').addEventListener('click', () => {
            state.lang = state.lang === 'cn' ? 'en' : 'cn';
            updateLangUI();
            // æ›´æ–°æŒ‰é’®æ–‡æœ¬
            const viewLangToggle = document.getElementById('view-lang-toggle');
            if (viewLangToggle) {
                viewLangToggle.innerText = state.lang === 'cn' ? 'EN / ä¸­' : 'ä¸­ / EN';
            }
            // æ›´æ–°æ•ˆæœé€‰æ‹©å™¨çš„æ ‡ç­¾
            const effectLabel = document.querySelector('#effect-controls label');
            if (effectLabel) {
                effectLabel.innerText = state.lang === 'cn' ? 'âœ¨ è§†è§‰æ•ˆæœï¼š' : 'âœ¨ Visual Effects:';
            }
            // æ›´æ–°æ•ˆæœé€‰é¡¹æ–‡æœ¬
            const effectSelect = document.getElementById('effect-select');
            if (effectSelect) {
                const options = effectSelect.options;
                if (state.lang === 'cn') {
                    // Reveal effects
                    options[0].text = 'æ— æ•ˆæœ';
                    options[1].text = 'é­”æ³•';
                    options[2].text = 'æ‰©æ•£';
                    options[3].text = 'å±•å¼€';
                    options[4].text = 'é¾™å·é£';
                    options[5].text = 'é›¨';
                    // Shader effects
                    if (options.length > 6) {
                        options[6].text = 'æ³¢æµª';
                        options[7].text = 'åˆ†è§£';
                    }
                } else {
                    // Reveal effects
                    options[0].text = 'None';
                    options[1].text = 'Magic';
                    options[2].text = 'Spread';
                    options[3].text = 'Unroll';
                    options[4].text = 'Twister';
                    options[5].text = 'Rain';
                    // Shader effects
                    if (options.length > 6) {
                        options[6].text = 'Waves';
                        options[7].text = 'Disintegrate';
                    }
                }
            }
            // æ›´æ–°è¿”å›æŒ‰é’®æ–‡æœ¬
            const closeSplat = document.getElementById('close-splat');
            if (closeSplat) {
                closeSplat.innerText = state.lang === 'cn' ? 'â† è¿”å›åœ°å›¾' : 'â† Back to Map';
            }
        });

        // ===== Audiuno ç”Ÿç†ä¿¡å·è¿æ¥ =====
        async function connectAudiuno() {
            if (!('serial' in navigator)) {
                alert('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Web Serial APIã€‚è¯·ä½¿ç”¨ Chromeã€Edge æˆ– Opera æµè§ˆå™¨ã€‚');
                return;
            }

            try {
                // è¯·æ±‚ä¸²å£è¿æ¥
                const port = await navigator.serial.requestPort();
                await port.open({ baudRate: 9600 }); // æ ¹æ® audiuno çš„æ³¢ç‰¹ç‡è°ƒæ•´

                state.audiuno.port = port;
                state.audiuno.isConnected = true;
                // æ˜¯å¦æ¥å—å¿ƒè·³æ•°æ®ç”± UI å¼€å…³å†³å®š

                // æ›´æ–° UI
                document.getElementById('audiuno-status').textContent = 'å·²è¿æ¥';
                document.getElementById('connect-audiuno-btn').textContent = 'æ–­å¼€è¿æ¥';
                document.getElementById('heart-rate-display').style.display = 'block';
                const hbToggle = document.getElementById('use-heartbeat-toggle');
                if (hbToggle) state.audiuno.usePhysiological = !!hbToggle.checked;

                // å¼€å§‹è¯»å–æ•°æ®
                readAudiunoData();

            } catch (err) {
                console.error('è¿æ¥ Audiuno å¤±è´¥:', err);
                if (err.name !== 'NotFoundError') {
                    alert('è¿æ¥å¤±è´¥: ' + err.message);
                }
            }
        }

        async function disconnectAudiuno() {
            if (state.audiuno.reader) {
                await state.audiuno.reader.cancel();
                state.audiuno.reader = null;
            }
            if (state.audiuno.port) {
                await state.audiuno.port.close();
                state.audiuno.port = null;
            }
            state.audiuno.isConnected = false;
            state.audiuno.heartRate = 0;
            state.audiuno.lastHeartbeatTime = 0;

            // æ›´æ–° UI
            document.getElementById('audiuno-status').textContent = 'æœªè¿æ¥';
            document.getElementById('connect-audiuno-btn').textContent = 'ğŸ”Œ è¿æ¥ Audiuno';
            document.getElementById('heart-rate-display').style.display = 'none';
            document.getElementById('heart-rate-value').textContent = '--';
        }

        async function readAudiunoData() {
            const decoder = new TextDecoder();
            let buffer = '';

            try {
                const reader = state.audiuno.port.readable.getReader();
                state.audiuno.reader = reader;

                while (state.audiuno.isConnected) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    
                    // è§£ææ•°æ®ï¼ˆå‡è®¾æ ¼å¼ä¸º "HR:75\n" æˆ– JSON æ ¼å¼ï¼‰
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || ''; // ä¿ç•™ä¸å®Œæ•´çš„è¡Œ

                    for (const line of lines) {
                        if (line.trim()) {
                            parsePhysiologicalData(line.trim());
                        }
                    }
                }
            } catch (err) {
                console.error('è¯»å–æ•°æ®å¤±è´¥:', err);
                if (state.audiuno.isConnected) {
                    await disconnectAudiuno();
                }
            }
        }

        function parsePhysiologicalData(data) {
            // è§£æå¤šç§å¯èƒ½çš„æ•°æ®æ ¼å¼
            // æ ¼å¼1: "HR:75" æˆ– "heartRate:75"
            const hrMatch = data.match(/(?:HR|heartRate|å¿ƒç‡)[:\s]+(\d+)/i);
            if (hrMatch) {
                const hr = parseInt(hrMatch[1]);
                if (hr > 0 && hr < 250) {
                    updateHeartRate(hr);
                }
                return;
            }

            // æ ¼å¼2: JSON æ ¼å¼ {"heartRate": 75, "bpm": 75}
            try {
                const json = JSON.parse(data);
                if (json.heartRate || json.bpm || json.hr) {
                    const hr = json.heartRate || json.bpm || json.hr;
                    if (hr > 0 && hr < 250) {
                        updateHeartRate(hr);
                    }
                }
            } catch (e) {
                // ä¸æ˜¯ JSONï¼Œå°è¯•å…¶ä»–æ ¼å¼
            }

            // æ ¼å¼3: çº¯æ•°å­—ï¼ˆå‡è®¾æ˜¯å¿ƒç‡ï¼‰
            const numMatch = data.match(/^\d+$/);
            if (numMatch) {
                const hr = parseInt(numMatch[0]);
                if (hr > 40 && hr < 200) {
                    updateHeartRate(hr);
                }
            }
        }

        function updateHeartRate(hr) {
            const previousHR = state.audiuno.heartRate;
            state.audiuno.heartRate = hr;
            document.getElementById('heart-rate-value').textContent = hr;

            // æ£€æµ‹å¿ƒè·³äº‹ä»¶ï¼šå½“å¿ƒç‡å€¼å˜åŒ–æ—¶ï¼Œè®°å½•å¿ƒè·³æ—¶é—´
            // æˆ–è€…å¯ä»¥é€šè¿‡å¿ƒç‡é—´éš”æ¥é¢„æµ‹ä¸‹ä¸€æ¬¡å¿ƒè·³
            if (state.audiuno.usePhysiological && previousHR > 0 && hr !== previousHR) {
                // è®°å½•å¿ƒè·³æ—¶é—´ï¼ˆç›¸å¯¹äº baseTimeï¼‰
                state.audiuno.lastHeartbeatTime = state.baseTime;
                // æ·»åŠ åˆ°å¿ƒè·³å†å²è®°å½•ï¼ˆä¿ç•™æœ€è¿‘ 5 æ¬¡ï¼‰
                if (!state.audiuno.heartbeatTimes) {
                    state.audiuno.heartbeatTimes = [];
                }
                state.audiuno.heartbeatTimes.push(state.baseTime);
                // åªä¿ç•™æœ€è¿‘ 5 æ¬¡å¿ƒè·³
                if (state.audiuno.heartbeatTimes.length > 5) {
                    state.audiuno.heartbeatTimes.shift();
                }
                console.log('ğŸ’“ å¿ƒè·³æ£€æµ‹:', hr, 'BPM, æ—¶é—´:', state.audiuno.lastHeartbeatTime, 'å†å²è®°å½•:', state.audiuno.heartbeatTimes.length);
            } else if (state.audiuno.usePhysiological && previousHR === 0 && hr > 0) {
                // é¦–æ¬¡æ”¶åˆ°å¿ƒç‡æ•°æ®ï¼Œåˆå§‹åŒ–å¿ƒè·³æ—¶é—´
                state.audiuno.lastHeartbeatTime = state.baseTime;
                if (!state.audiuno.heartbeatTimes) {
                    state.audiuno.heartbeatTimes = [];
                }
                state.audiuno.heartbeatTimes.push(state.baseTime);
                
                // å¦‚æœå½“å‰æ˜¯"æ— æ•ˆæœ"æ¨¡å¼ï¼Œéœ€è¦é‡æ–°åˆ›å»º modifier ä»¥åº”ç”¨å¿ƒè·³æ³¢æµª
                if (state.splatMesh && state.effectParams.effect === 'None') {
                    console.log('é¦–æ¬¡æ”¶åˆ°å¿ƒè·³æ•°æ®ï¼Œåœ¨æ— æ•ˆæœæ¨¡å¼ä¸‹é‡æ–°åˆ›å»º modifier');
                    setupSplatModifier(state.splatMesh, 'None');
                    if (state.splatMesh.updateVersion) {
                        state.splatMesh.updateVersion();
                    }
                }
            }

            // å°†å¿ƒç‡æ˜ å°„åˆ°æ•ˆæœå‚æ•°
            // æ­£å¸¸å¿ƒç‡èŒƒå›´ï¼š60-100 BPMï¼Œæ˜ å°„åˆ° intensity: 0.3-1.0
            // æˆ–è€…æ˜ å°„åˆ°åŠ¨ç”»é€Ÿåº¦ç­‰å…¶ä»–å‚æ•°
            if (state.audiuno.usePhysiological && state.splatMesh) {
                // æ˜ å°„å¿ƒç‡åˆ° intensity (60-100 BPM -> 0.3-1.0)
                const normalizedHR = Math.max(0, Math.min(1, (hr - 60) / 40));
                const mappedIntensity = 0.3 + normalizedHR * 0.7;
                
                // æ›´æ–°æ•ˆæœå‚æ•°
                state.effectParams.intensity = mappedIntensity;
                
                // æ›´æ–° UI
                const intensitySlider = document.getElementById('intensity-slider');
                const intensityValue = document.getElementById('intensity-value');
                if (intensitySlider && intensityValue) {
                    intensitySlider.value = mappedIntensity;
                    intensityValue.textContent = mappedIntensity.toFixed(2);
                }

                // é‡æ–°åº”ç”¨æ•ˆæœ
                if (state.effectParams.effect !== 'None') {
                    setupSplatModifier(state.splatMesh, state.effectParams.effect);
                    if (state.splatMesh.updateVersion) {
                        state.splatMesh.updateVersion();
                    }
                }
            }
        }

        // åŸºäºå¿ƒç‡é¢„æµ‹å¿ƒè·³äº‹ä»¶ï¼ˆå¦‚æœ audiuno åªå‘é€å¿ƒç‡å€¼ï¼Œä¸å‘é€å¿ƒè·³äº‹ä»¶ï¼‰
        function predictHeartbeat() {
            if (!state.audiuno.usePhysiological || state.audiuno.heartRate <= 0) return;
            
            // è®¡ç®—å¿ƒè·³é—´éš”ï¼ˆç§’ï¼‰
            const heartbeatInterval = 60.0 / state.audiuno.heartRate;
            
            // å¦‚æœè·ç¦»ä¸Šæ¬¡å¿ƒè·³çš„æ—¶é—´è¶…è¿‡é—´éš”ï¼Œè§¦å‘æ–°å¿ƒè·³
            const timeSinceLastBeat = state.baseTime - state.audiuno.lastHeartbeatTime;
            if (timeSinceLastBeat >= heartbeatInterval) {
                state.audiuno.lastHeartbeatTime = state.baseTime;
                // æ·»åŠ åˆ°å¿ƒè·³å†å²è®°å½•
                if (!state.audiuno.heartbeatTimes) {
                    state.audiuno.heartbeatTimes = [];
                }
                state.audiuno.heartbeatTimes.push(state.baseTime);
                // åªä¿ç•™æœ€è¿‘ 5 æ¬¡å¿ƒè·³
                if (state.audiuno.heartbeatTimes.length > 5) {
                    state.audiuno.heartbeatTimes.shift();
                }
                console.log('ğŸ’“ é¢„æµ‹å¿ƒè·³:', state.audiuno.heartRate, 'BPM, å†å²è®°å½•:', state.audiuno.heartbeatTimes.length);
            }
        }

        // Audiuno è¿æ¥æŒ‰é’®äº‹ä»¶
        document.getElementById('connect-audiuno-btn').addEventListener('click', async () => {
            if (state.audiuno.isConnected) {
                await disconnectAudiuno();
            } else {
                await connectAudiuno();
            }
        });

        // æ˜¯å¦æ¥å—å¿ƒè·³æ•°æ®å¼€å…³
        const useHeartbeatToggle = document.getElementById('use-heartbeat-toggle');
        if (useHeartbeatToggle) {
            useHeartbeatToggle.addEventListener('change', () => {
                state.audiuno.usePhysiological = !!useHeartbeatToggle.checked;
                if (!state.audiuno.usePhysiological) {
                    // å…³é—­æ—¶æ¸…ç©ºå¿ƒè·³æ—¶é—´ï¼Œé¿å…æ®‹ç•™æ³¢æµª
                    state.audiuno.lastHeartbeatTime = 0;
                } else if (state.audiuno.heartRate > 0 && state.audiuno.lastHeartbeatTime === 0) {
                    // é‡æ–°å¼€å¯æ—¶ï¼Œåˆå§‹åŒ–ä¸€ä¸ªå¿ƒè·³æ—¶é—´
                    state.audiuno.lastHeartbeatTime = state.baseTime;
                }
            });
        }

        loadLocations();
        setInterval(loadLocations, 20000);
        updateLangUI();
    </script>
</body>
</html>
