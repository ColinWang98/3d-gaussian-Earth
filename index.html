<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HK 3DGS Hub | Pro Holographic Map</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
    <style>
        :root { --primary: #00ff88; --danger: #ff4444; --glass: rgba(10, 15, 30, 0.95); --accent: #0072ff; }
        body, html { margin: 0; padding: 0; height: 100%; background: #000; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        #map-background { position: absolute; inset: 0; z-index: 1; }
        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 1000; }
        .pointer-auto { pointer-events: auto; }
        #app-title { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: white; font-size: 28px; font-weight: 300; letter-spacing: 2px; z-index: 1001; pointer-events: none; text-shadow: 0 2px 10px rgba(0,0,0,0.5); }
        #lang-toggle { position: absolute; top: 20px; left: 20px; background: var(--glass); color: white; border: 1px solid #444; padding: 8px 15px; border-radius: 20px; cursor: pointer; z-index: 1001; }
        #map-style-toggle { position: absolute; top: 20px; left: 90px; background: var(--glass); color: white; border: 1px solid #444; padding: 8px 15px; border-radius: 20px; cursor: pointer; z-index: 1001; font-size: 0.9em; }
        #upload-btn { position: absolute; top: 20px; right: 20px; background: var(--accent); border: none; padding: 12px 24px; border-radius: 50px; color: white; font-weight: bold; cursor: pointer; z-index: 1001; }
        #info-bar { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 450px; background: var(--glass); padding: 20px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1); color: white; display: none; }
        #splat-viewer { position: absolute; inset: 0; background: transparent; z-index: 9999; display: none; }
        /* ç¡®ä¿ splat-viewer æœ¬èº«ä¸é˜»æŒ¡é¼ æ ‡äº‹ä»¶ï¼Œåªæœ‰å­å…ƒç´ å¯ä»¥äº¤äº’
           å…è®¸è¿”å›æŒ‰é’®ã€æ•ˆæœæ§åˆ¶é¢æ¿å’ŒèŠå¤©çª—å£æ¥æ”¶é¼ æ ‡äº‹ä»¶ */
        #splat-viewer > *:not(canvas):not(#close-splat):not(#chat-window):not(#effect-controls) { pointer-events: none; }
        #close-splat { position: absolute; top: 20px; left: 20px; z-index: 2100; padding: 10px 20px; border-radius: 20px; background: rgba(255,255,255,0.2); color: white; border: 1px solid white; cursor: pointer; pointer-events: auto; }
        #effect-controls { position: absolute; top: 20px; left: 200px; z-index: 2100; background: var(--glass); border-radius: 15px; border: 1px solid #333; padding: 15px; min-width: 200px; pointer-events: auto; display: none; }
        #effect-controls label { color: white; font-size: 0.9em; display: block; margin-bottom: 8px; }
        #effect-select { width: 100%; padding: 8px; background: #050510; border: 1px solid #444; color: white; border-radius: 8px; cursor: pointer; }
        /* ä¸ºäº†ç¡®ä¿ 3D ç”»å¸ƒå¯äº¤äº’ï¼ŒèŠå¤©çª—å£ä¸æ‹¦æˆªé¼ æ ‡äº‹ä»¶ */
        #chat-window { position: absolute; bottom: 20px; right: 20px; width: 320px; height: 400px; background: var(--glass); border-radius: 15px; border: 1px solid #333; display: none; flex-direction: column; z-index: 2100; box-shadow: 0 12px 40px rgba(0,0,0,0.6); overflow: hidden; }
        #chat-msgs { flex: 1; padding: 12px; overflow-y: auto; font-size: 0.85em; color: #eee; display: flex; flex-direction: column; gap: 10px; }
        .msg { padding: 10px 14px; border-radius: 12px; max-width: 85%; }
        .msg-agent { background: var(--accent); align-self: flex-start; }
        .msg-user { background: #333; align-self: flex-end; }
        #chat-input-wrap { display: flex; border-top: 1px solid #333; padding: 10px; background: rgba(0,0,0,0.3); }
        #chat-input { flex: 1; background: transparent; border: none; color: white; outline: none; }
        #modal-overlay { display: none; position: absolute; inset: 0; background: rgba(0,0,0,0.85); justify-content: center; align-items: center; z-index: 3000; pointer-events: auto; }
        .modal-box { background: #151525; padding: 25px; border-radius: 16px; width: 90%; max-width: 400px; color: white; border: 1px solid #333; }
        input, textarea { width: 100%; box-sizing: border-box; background: #050510; border: 1px solid #444; color: white; padding: 12px; border-radius: 8px; margin: 10px 0; }
        /* åŠ è½½æç¤ºï¼šæ”¹ä¸ºå³ä¸Šè§’å°å¾½æ ‡ï¼Œè€Œä¸æ˜¯å…¨å±é®ç½©ï¼Œä¸”ä¸æ‹¦æˆªäº¤äº’ */
        #loading-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            min-width: 160px;
            padding: 6px 14px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 12px;
            z-index: 2100;
            pointer-events: none;
        }
        /* ç¡®ä¿æ‰€æœ‰ canvas éƒ½å¯ä»¥äº¤äº’ï¼Œä¸»æ¸²æŸ“ canvas åœ¨æœ€ä¸Šå±‚ */
        #splat-viewer canvas { pointer-events: auto !important; position: absolute !important; top: 0 !important; left: 0 !important; width: 100% !important; height: 100% !important; z-index: 100 !important; }
    </style>
    <script type="importmap">{ "imports": { 
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.178.0/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/",
            "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.10/spark.module.js",
            "@huggingface/hub": "https://cdn.jsdelivr.net/npm/@huggingface/hub@0.15.1/+esm"
    }}</script>
</head>
<body>
    <div id="map-background"></div>
    <div id="splat-viewer" class="pointer-auto">
        <div id="loading-overlay"></div>
        <button id="close-splat">â† è¿”å›åœ°å›¾</button>
        <div id="effect-controls">
            <label for="effect-select">âœ¨ è§†è§‰æ•ˆæœï¼š</label>
            <select id="effect-select">
                <option value="None">æ— æ•ˆæœ</option>
                <option value="Magic">é­”æ³•</option>
                <option value="Spread">æ‰©æ•£</option>
                <option value="Unroll">å±•å¼€</option>
                <option value="Twister">é¾™å·é£</option>
                <option value="Rain">é›¨</option>
            </select>
        </div>
        <div id="chat-window">
            <div id="gemini-config-ui" style="padding:20px; text-align:center;">
                <p style="color:var(--primary); font-size:0.9em;">ğŸ‘¤ æ¿€æ´» AI å¯¼è§ˆå‘˜</p>
                <input type="password" id="user-gemini-key" placeholder="Gemini API Key...">
                <button id="save-key-btn" style="background:var(--accent); color:white; border:none; padding:10px; width:100%; border-radius:8px; cursor:pointer;">å¼€å¯ AI å¯¹è¯</button>
            </div>
            <div id="chat-main-ui" style="display:none; flex-direction:column; height:100%;">
                <div id="chat-msgs"></div>
                <div id="chat-input-wrap">
                    <input type="text" id="chat-input" placeholder="æé—®...">
                    <button id="chat-send" style="background:none; border:none; color:var(--primary); cursor:pointer;">å‘é€</button>
                </div>
            </div>
        </div>
    </div>

    <div id="ui-layer">
        <h1 id="app-title">Spatial Memory Map</h1>
        <button id="lang-toggle" class="pointer-auto">EN / ä¸­</button>
        <button id="map-style-toggle" class="pointer-auto">ğŸ—ºï¸ åœ°å›¾æ ·å¼</button>
        <button id="upload-btn" class="pointer-auto">+ æ–°å¢ä»»åŠ¡</button>
        <div id="info-bar" class="pointer-auto">
            <h3 id="loc-title" style="margin:0"></h3>
            <p id="loc-desc" style="color:#aaa; font-size:0.85em; margin:10px 0;"></p>
            <div style="display:flex; justify-content:space-between; gap:10px;">
                <button id="del-btn" style="background:var(--danger); border:none; padding:8px 15px; border-radius:10px; color:white; cursor:pointer; font-weight:bold;">åˆ é™¤</button>
                <button id="enter-btn" style="background:var(--primary); border:none; padding:10px 25px; border-radius:20px; cursor:pointer; font-weight:bold; color:#000;">å…¨æ¯æŸ¥çœ‹</button>
            </div>
        </div>
    </div>

    <div id="modal-overlay">
        <div class="modal-box">
            <h3 style="margin:0 0 15px 0">åˆ›å»ºé‡å»ºä»»åŠ¡</h3>
            <input type="password" id="hf-token" placeholder="Hugging Face Write Token">
            <input type="password" id="deepl-key" placeholder="DeepL API Key (å¯é€‰ï¼Œç”¨äºè‡ªåŠ¨ç¿»è¯‘)">
            <input type="text" id="loc-name" placeholder="åœ°ç‚¹åç§° (ä¸­æ–‡)">
            <input type="text" id="loc-name-en" placeholder="Location Name (Englishï¼Œç•™ç©ºå°†è‡ªåŠ¨ç¿»è¯‘)">
            <div style="display:flex; gap:8px;">
                <input type="text" id="lat-lon" readonly placeholder="ç‚¹å‡»åœ°å›¾æ‹¾å–åæ ‡">
                <button id="pick-btn" style="background:var(--accent); border:none; padding:0 15px; border-radius:8px; color:white; cursor:pointer;">æ‹¾å–</button>
            </div>
            <input type="file" id="photo-input" accept="image/*">
            <textarea id="desc-input" rows="2" placeholder="è¯·è¾“å…¥æè¿° (ä¸­æ–‡ï¼Œå°†è‡ªåŠ¨ç¿»è¯‘ä¸ºè‹±æ–‡)..."></textarea>
            <button id="submit-btn" style="width:100%; background:var(--primary); border:none; padding:12px; border-radius:8px; font-weight:bold; cursor:pointer; margin-top:10px;">ä¸Šä¼ ä»»åŠ¡</button>
            <button onclick="document.getElementById('modal-overlay').style.display='none'" style="width:100%; background:none; border:none; color:#888; margin-top:10px; cursor:pointer;">å–æ¶ˆ</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
    <script type="module">
        import { commit } from '@huggingface/hub';
        import * as THREE from 'three';
        import { SparkControls, SplatMesh, dyno } from '@sparkjsdev/spark';

        const REPO_ID = "ColinWong24/my-gaussian-world";
        const state = { locations: [], currentLoc: null, lang: 'cn', scene: null, camera: null, renderer: null, controls: null, splatMesh: null, animationId: null, resizeHandler: null, isPicking: false, selectedCoords: null, deeplKey: localStorage.getItem('DEEPL_KEY') || '', effectParams: { effect: 'None' }, animateT: null, baseTime: 0 };
        let ACTIVE_GEMINI_KEY = localStorage.getItem('MY_GEMINI_KEY') || '';
        
        // DeepL è‡ªåŠ¨ç¿»è¯‘å‡½æ•°
        async function translateWithDeepL(text, targetLang = 'EN') {
            if (!state.deeplKey || !text) return text;
            try {
                const res = await fetch('https://api-free.deepl.com/v2/translate', {
                    method: 'POST',
                    headers: {
                        'Authorization': `DeepL-Auth-Key ${state.deeplKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: [text],
                        target_lang: targetLang
                    })
                });
                if (!res.ok) throw new Error(`DeepL API é”™è¯¯: ${res.status}`);
                const data = await res.json();
                return data.translations[0].text;
            } catch (e) {
                console.warn('DeepL ç¿»è¯‘å¤±è´¥:', e);
                return text; // ç¿»è¯‘å¤±è´¥æ—¶è¿”å›åŸæ–‡
            }
        }

        function updateLangUI() {
            const langBtn = document.getElementById('lang-toggle');
            if (langBtn) langBtn.innerText = state.lang === 'cn' ? 'EN / ä¸­' : 'ä¸­ / EN';

            // æ ¹æ®è¯­è¨€åˆ‡æ¢å½“å‰åœ°ç‚¹æ ‡é¢˜å’Œæè¿°ï¼ˆå¦‚æœæœ‰è‹±æ–‡å­—æ®µï¼‰
            if (state.currentLoc) {
                const loc = state.currentLoc;
                const titleEl = document.getElementById('loc-title');
                const descEl = document.getElementById('loc-desc');
                if (state.lang === 'cn') {
                    titleEl.innerText = loc.name || '';
                    descEl.innerText = loc.desc || 'å¤„ç†ä¸­...';
                } else {
                    titleEl.innerText = loc.name_en || loc.name || '';
                    descEl.innerText = loc.desc_en || loc.desc || 'Processing...';
                }
            }

            // åŒæ­¥æ›´æ–°åœ°å›¾æ ·å¼æŒ‰é’®çš„æ–‡æ¡ˆ
            updateMapStyleButton();
        }

        // ===== AI èŠå¤©ç›¸å…³ =====
        function addChatMessage(role, text) {
            const msgs = document.getElementById('chat-msgs');
            if (!msgs) return;
            const div = document.createElement('div');
            div.className = `msg msg-${role}`;
            div.innerText = text;
            msgs.appendChild(div);
            msgs.scrollTop = msgs.scrollHeight;
        }

        function showChatUI() {
            const chatWin = document.getElementById('chat-window');
            if (!chatWin) return;
            chatWin.style.display = 'flex';

            const cfg = document.getElementById('gemini-config-ui');
            const main = document.getElementById('chat-main-ui');

            if (ACTIVE_GEMINI_KEY) {
                cfg.style.display = 'none';
                main.style.display = 'flex';
                // é¦–æ¬¡æ‰“å¼€å½“å‰åœ°ç‚¹æ—¶æ‰“ä¸ªæ‹›å‘¼
                if (document.getElementById('chat-msgs').children.length === 0 && state.currentLoc) {
                    const locName = state.currentLoc.name || state.currentLoc.name_en || 'è¿™ä¸ªåœ°æ–¹';
                    addChatMessage('agent', `ä½ å¥½ï¼Œæˆ‘æ˜¯è¿™ä¸ªåœºæ™¯çš„æ‹æ‘„è€…ï¼Œç°åœ¨å¸¦ä½ çœ‹ï¼š${locName}ã€‚å¯ä»¥éšä¾¿é—®æˆ‘é—®é¢˜ï½`);
                }
            } else {
                cfg.style.display = 'block';
                main.style.display = 'none';
            }
        }

        // å°†å›¾ç‰‡ URL è½¬æ¢ä¸º base64
        async function imageUrlToBase64(imageUrl) {
            try {
                const response = await fetch(imageUrl);
                const blob = await response.blob();
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const base64 = reader.result.split(',')[1]; // ç§»é™¤ data:image/...;base64, å‰ç¼€
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (e) {
                console.error('å›¾ç‰‡è½¬æ¢å¤±è´¥:', e);
                return null;
            }
        }

        async function handleChat() {
            if (!ACTIVE_GEMINI_KEY) {
                alert('è¯·å…ˆåœ¨å³ä¸‹è§’è¾“å…¥ Gemini API Key');
                return;
            }
            const input = document.getElementById('chat-input');
            const text = (input.value || '').trim();
            if (!text) return;
            addChatMessage('user', text);
            input.value = '';

            const loc = state.currentLoc || {};
            const locName = loc.name_en || loc.name || '';
            const locDesc = loc.desc_en || loc.desc || '';
            const sys = `ä½ æ˜¯ 3D å…¨æ¯åœºæ™¯çš„æ‹æ‘„è€…ï¼Œä»¥ç¬¬ä¸€äººç§°ã€å£è¯­åŒ–ç®€çŸ­å›ç­”ç”¨æˆ·é—®é¢˜ï¼Œå¤šç”¨"å””"ã€"å•Š"ã€"å…¶å®"ç­‰å£å¤´è¯­ã€‚
åœ°ç‚¹: ${locName}
èƒŒæ™¯: ${locDesc}`;

            try {
                // æ„å»ºè¯·æ±‚çš„ parts æ•°ç»„
                const parts = [{ text: sys }];
                
                // å¦‚æœæœ‰å›¾ç‰‡ï¼Œæ·»åŠ åˆ°è¯·æ±‚ä¸­
                if (loc.photoPath) {
                    const imageUrl = `https://huggingface.co/datasets/${REPO_ID}/resolve/main/${loc.photoPath}`;
                    const base64Image = await imageUrlToBase64(imageUrl);
                    if (base64Image) {
                        // æ ¹æ®æ–‡ä»¶æ‰©å±•åç¡®å®š MIME ç±»å‹
                        const mimeType = loc.photoPath.toLowerCase().endsWith('.png') ? 'image/png' : 'image/jpeg';
                        parts.push({
                            inlineData: {
                                mimeType: mimeType,
                                data: base64Image
                            }
                        });
                    }
                }
                
                // æ·»åŠ ç”¨æˆ·çš„é—®é¢˜
                parts.push({ text: text });

                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${ACTIVE_GEMINI_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [
                            { role: 'user', parts: parts }
                        ]
                    })
                });
                const data = await res.json();
                const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || 'å””ï¼Œæˆ‘ä¸€æ—¶é—´æœ‰ç‚¹æƒ³ä¸åˆ°ï¼Œç­‰æˆ‘å†ç ”ç©¶ä¸‹å…ˆï½';
                addChatMessage('agent', reply);
            } catch (e) {
                console.error('Gemini è°ƒç”¨å¤±è´¥:', e);
                addChatMessage('agent', 'å””ï¼ŒAI é‚£è¾¹è¿ä¸ä¸Šç½‘ç»œäº†ï¼Œä¸€é˜µå†è¯•è¯•å•¦ã€‚');
            }
        }

        // 1. åˆå§‹åŒ–åœ°å›¾ [web:13]
        const map = L.map('map-background', { center: [22.3193, 114.1694], zoom: 13, zoomControl: false });
        
        // åœ°å›¾æ ·å¼é…ç½®
        const mapStyles = {
            dark: {
                nameCn: 'æ·±è‰²',
                nameEn: 'Dark',
                url: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'
            },
            light: {
                nameCn: 'æµ…è‰²',
                nameEn: 'Light',
                url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png'
            },
            satellite: {
                nameCn: 'å«æ˜Ÿ',
                nameEn: 'Satellite',
                url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
            },
            terrain: {
                nameCn: 'åœ°å½¢',
                nameEn: 'Terrain',
                url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png'
            }
        };
        
        let currentMapStyle = 'dark';
        let currentTileLayer = L.tileLayer(mapStyles[currentMapStyle].url).addTo(map);
        const markerGroup = L.layerGroup().addTo(map);

        function updateMapStyleButton() {
            const btn = document.getElementById('map-style-toggle');
            if (!btn) return;
            const styleCfg = mapStyles[currentMapStyle];
            if (!styleCfg) return;
            const name = state.lang === 'cn' ? styleCfg.nameCn : styleCfg.nameEn;
            btn.innerText = `ğŸ—ºï¸ ${name}`;
        }
        
        // åœ°å›¾æ ·å¼åˆ‡æ¢åŠŸèƒ½
        document.getElementById('map-style-toggle').onclick = () => {
            const styles = Object.keys(mapStyles);
            const currentIndex = styles.indexOf(currentMapStyle);
            const nextIndex = (currentIndex + 1) % styles.length;
            currentMapStyle = styles[nextIndex];
            
            // ç§»é™¤æ—§å›¾å±‚
            map.removeLayer(currentTileLayer);
            
            // æ·»åŠ æ–°å›¾å±‚
            currentTileLayer = L.tileLayer(mapStyles[currentMapStyle].url).addTo(map);
            
            // æ›´æ–°æŒ‰é’®æ–‡æœ¬ï¼ˆæ ¹æ®å½“å‰è¯­è¨€æ˜¾ç¤ºä¸­/è‹±æ–‡ï¼‰
            updateMapStyleButton();
        };

        // 2. æ•°æ®åŠ è½½ä¸åŒæ­¥ [web:18]
        async function loadLocations() {
            try {
                const res = await fetch(`https://huggingface.co/datasets/${REPO_ID}/resolve/main/locations.json?t=${Date.now()}`);
                state.locations = await res.json();
                markerGroup.clearLayers();
                state.locations.forEach(loc => {
                    const ready = loc.status === 'ready';
                    L.circleMarker([loc.lat, loc.lon], { radius: 10, fillColor: ready ? '#00ff88' : '#ffcc00', fillOpacity: 0.8, color: '#fff', weight: 2 })
                    .addTo(markerGroup).on('click', () => {
                        state.currentLoc = loc;
                        state.currentLoc = loc;
                        // æ ¹æ®å½“å‰è¯­è¨€æ¸²æŸ“æ ‡é¢˜ä¸æè¿°
                        if (state.lang === 'cn') {
                            document.getElementById('loc-title').innerText = loc.name;
                            document.getElementById('loc-desc').innerText = loc.desc || "å¤„ç†ä¸­...";
                        } else {
                            document.getElementById('loc-title').innerText = loc.name_en || loc.name;
                            document.getElementById('loc-desc').innerText = loc.desc_en || loc.desc || "Processing...";
                        }
                        document.getElementById('info-bar').style.display = 'block';
                        document.getElementById('enter-btn').disabled = !ready;
                        document.getElementById('enter-btn').style.opacity = ready ? "1" : "0.5";
                    });
                });
            } catch(e) { console.error("åŠ è½½å¤±è´¥", e); }
        }

        // è®¾ç½® Splat è§†è§‰æ•ˆæœ
        function setupSplatModifier(splatMesh, effectType) {
            if (effectType === 'None') {
                splatMesh.objectModifier = null;
                splatMesh.updateGenerator();
                return;
            }

            const effectTypeMap = {
                'Magic': 1,
                'Spread': 2,
                'Unroll': 3,
                'Twister': 4,
                'Rain': 5
            };

            const effectInt = effectTypeMap[effectType] || 1;

            splatMesh.objectModifier = dyno.dynoBlock(
                { gsplat: dyno.Gsplat },
                { gsplat: dyno.Gsplat },
                ({ gsplat }) => {
                    const d = new dyno.Dyno({
                        inTypes: { gsplat: dyno.Gsplat, t: "float", effectType: "int" },
                        outTypes: { gsplat: dyno.Gsplat },
                        globals: () => [
                            dyno.unindent(`
                                vec3 hash(vec3 p) {
                                    p = fract(p * 0.3183099 + 0.1);
                                    p *= 17.0;
                                    return fract(vec3(p.x * p.y * p.z, p.x + p.y * p.z, p.x * p.y + p.z));
                                }

                                vec3 noise(vec3 p) {
                                    vec3 i = floor(p);
                                    vec3 f = fract(p);
                                    f = f * f * (3.0 - 2.0 * f);
                                    
                                    vec3 n000 = hash(i + vec3(0,0,0));
                                    vec3 n100 = hash(i + vec3(1,0,0));
                                    vec3 n010 = hash(i + vec3(0,1,0));
                                    vec3 n110 = hash(i + vec3(1,1,0));
                                    vec3 n001 = hash(i + vec3(0,0,1));
                                    vec3 n101 = hash(i + vec3(1,0,1));
                                    vec3 n011 = hash(i + vec3(0,1,1));
                                    vec3 n111 = hash(i + vec3(1,1,1));
                                    
                                    vec3 x0 = mix(n000, n100, f.x);
                                    vec3 x1 = mix(n010, n110, f.x);
                                    vec3 x2 = mix(n001, n101, f.x);
                                    vec3 x3 = mix(n011, n111, f.x);
                                    
                                    vec3 y0 = mix(x0, x1, f.y);
                                    vec3 y1 = mix(x2, x3, f.y);
                                    
                                    return mix(y0, y1, f.z);
                                }

                                mat2 rot(float a) {
                                    float s=sin(a),c=cos(a);
                                    return mat2(c,-s,s,c);
                                }

                                vec4 twister(vec3 pos, vec3 scale, float t) {
                                    vec3 h = hash(pos);
                                    float s = smoothstep(0., 8., t*t*.1 - length(pos.xz)*2.+2.);
                                    if (length(scale) < .05) pos.y = mix(-10., pos.y, pow(s, 2.*h.x));
                                    pos.xz = mix(pos.xz*.5, pos.xz, pow(s, 2.*h.x));
                                    float rotationTime = t * (1.0 - s) * 0.2;
                                    pos.xz *= rot(rotationTime + pos.y*20.*(1.-s)*exp(-1.*length(pos.xz)));
                                    return vec4(pos, s*s*s*s);
                                }

                                vec4 rain(vec3 pos, vec3 scale, float t) {
                                    vec3 h = hash(pos);
                                    float s = pow(smoothstep(0., 5., t*t*.1 - length(pos.xz)*2. + 1.), .5 + h.x);
                                    float y = pos.y;
                                    pos.y = min(-10. + s*15., pos.y);
                                    pos.xz = mix(pos.xz*.3, pos.xz, s);
                                    pos.xz *= rot(t*.3);
                                    return vec4(pos, smoothstep(-10., y, pos.y));
                                }
                            `)
                        ],
                        statements: ({ inputs, outputs }) => dyno.unindentLines(`
                            ${outputs.gsplat} = ${inputs.gsplat};
                            float t = ${inputs.t};
                            float s = smoothstep(0.,10.,t-4.5)*10.;
                            vec3 scales = ${inputs.gsplat}.scales;
                            vec3 localPos = ${inputs.gsplat}.center;
                            float l = length(localPos.xz);
                            
                            if (${inputs.effectType} == 1) {
                                float border = abs(s-l-.5);
                                localPos *= 1.-.2*exp(-20.*border);
                                vec3 finalScales = mix(scales,vec3(0.002),smoothstep(s-.5,s,l+.5));
                                ${outputs.gsplat}.center = localPos + .1*noise(localPos.xyz*2.+t*.5)*smoothstep(s-.5,s,l+.5);
                                ${outputs.gsplat}.scales = finalScales;
                                float at = atan(localPos.x,localPos.z)/3.1416;
                                ${outputs.gsplat}.rgba *= step(at,t-3.1416);
                                ${outputs.gsplat}.rgba += exp(-20.*border) + exp(-50.*abs(t-at-3.1416))*.5;
                                
                            } else if (${inputs.effectType} == 2) {
                                float tt = t*t*.4+.5;
                                localPos.xz *= min(1.,.3+max(0.,tt*.05));
                                ${outputs.gsplat}.center = localPos;
                                ${outputs.gsplat}.scales = max(mix(vec3(0.0),scales,min(tt-7.-l*2.5,1.)),mix(vec3(0.0),scales*.2,min(tt-1.-l*2.,1.)));
                                ${outputs.gsplat}.rgba = mix(vec4(.3),${inputs.gsplat}.rgba,clamp(tt-l*2.5-3.,0.,1.));
                                
                            } else if (${inputs.effectType} == 3) {
                                localPos.xz *= rot((localPos.y*50.-20.)*exp(-t));
                                ${outputs.gsplat}.center = localPos * (1.-exp(-t)*2.);
                                ${outputs.gsplat}.scales = mix(vec3(0.002),scales,smoothstep(.3,.7,t+localPos.y-2.));
                                ${outputs.gsplat}.rgba = ${inputs.gsplat}.rgba*step(0.,t*.5+localPos.y-.5);
                            } else if (${inputs.effectType} == 4) {
                                vec4 effectResult = twister(localPos, scales, t);
                                ${outputs.gsplat}.center = effectResult.xyz;
                                ${outputs.gsplat}.scales = mix(vec3(.002), scales, pow(effectResult.w, 12.));
                                float s = effectResult.w;
                                float spin = -t * 0.3 * (1.0 - s);
                                vec4 spinQ = vec4(0.0, sin(spin*0.5), 0.0, cos(spin*0.5));
                                ${outputs.gsplat}.quaternion = quatQuat(spinQ, ${inputs.gsplat}.quaternion);
                            } else if (${inputs.effectType} == 5) {
                                vec4 effectResult = rain(localPos, scales, t);
                                ${outputs.gsplat}.center = effectResult.xyz;
                                ${outputs.gsplat}.scales = mix(vec3(.005), scales, pow(effectResult.w, 30.));
                                float spin = -t*.3;
                                vec4 spinQ = vec4(0.0, sin(spin*0.5), 0.0, cos(spin*0.5));
                                ${outputs.gsplat}.quaternion = quatQuat(spinQ, ${inputs.gsplat}.quaternion);
                            }
                        `),
                    });

                    gsplat = d.apply({ 
                        gsplat, 
                        t: state.animateT,
                        effectType: dyno.dynoInt(effectInt)
                    }).gsplat;
                    
                    return { gsplat };
                }
            );

            splatMesh.updateGenerator();
        }

        // 3. æ ¸å¿ƒ 3D æ¸²æŸ“ - ä½¿ç”¨ Spark åº“
        document.getElementById('enter-btn').onclick = async () => {
            const container = document.getElementById('splat-viewer');
            const loader = document.getElementById('loading-overlay');
            container.style.display = 'block';
            loader.style.display = 'flex';

            // æ‰“å¼€ 3D è§†å›¾æ—¶éšè—åœ°å›¾å’Œä¸Šå±‚ UIï¼Œé¿å…æŒ¡ä½æ¨¡å‹äº¤äº’
            document.getElementById('ui-layer').style.display = 'none';
            document.getElementById('map-background').style.display = 'none';
            // ç¡®ä¿ä»»åŠ¡å¼¹çª—å…³é—­ï¼Œé¿å…ç°è‰²è’™å±‚æ®‹ç•™
            const modal = document.getElementById('modal-overlay');
            if (modal) modal.style.display = 'none';
            // æ˜¾ç¤ºèŠå¤©çª—å£ï¼ˆç”± showChatUI æ§åˆ¶å†…éƒ¨å†…å®¹ï¼‰
            showChatUI();
            
            // æ˜¾ç¤ºæ•ˆæœæ§åˆ¶é¢æ¿
            const effectControls = document.getElementById('effect-controls');
            if (effectControls) {
                effectControls.style.display = 'block';
                // è®¾ç½®å½“å‰é€‰æ‹©çš„æ•ˆæœ
                const effectSelect = document.getElementById('effect-select');
                if (effectSelect) {
                    effectSelect.value = state.effectParams.effect;
                }
            }

            // æ¸…ç†ä¹‹å‰çš„åœºæ™¯
            if (state.animationId) {
                cancelAnimationFrame(state.animationId);
                state.animationId = null;
            }
            if (state.renderer) {
                container.removeChild(state.renderer.domElement);
                state.renderer.dispose();
            }
            if (state.controls) {
                state.controls.dispose();
            }

            try {
                // åˆ›å»ºåœºæ™¯
                state.scene = new THREE.Scene();
                state.scene.background = new THREE.Color(0x1a1a1a);

                // åˆ›å»ºç›¸æœº
                state.camera = new THREE.PerspectiveCamera(
                    60,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                state.camera.position.set(0, 0, 5);

                // åˆ›å»ºæ¸²æŸ“å™¨
                state.renderer = new THREE.WebGLRenderer({ antialias: true });
                state.renderer.setSize(window.innerWidth, window.innerHeight);
                state.renderer.setPixelRatio(window.devicePixelRatio);
                state.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                state.renderer.toneMappingExposure = 1.2;
                container.appendChild(state.renderer.domElement);

                // åˆ›å»ºæ§åˆ¶å™¨ï¼ˆä½¿ç”¨ SparkControlsï¼‰
                state.controls = new SparkControls({ canvas: state.renderer.domElement });

                // åˆå§‹åŒ–åŠ¨ç”»æ—¶é—´
                state.animateT = dyno.dynoFloat(0);
                state.baseTime = 0;

                // åŠ è½½ splat æ¨¡å‹
                const url = `https://huggingface.co/datasets/${REPO_ID}/resolve/main/${state.currentLoc.splatPath}`;
                loader.innerText = 'ğŸ“¦ æ­£åœ¨è§£ææ¨¡å‹æ–‡ä»¶...';
                
                // åˆ›å»º SplatMesh
                state.splatMesh = new SplatMesh({ url: url });
                
                // æ·»åŠ åˆ°åœºæ™¯
                state.scene.add(state.splatMesh);
                
                // ç­‰å¾…æ¨¡å‹åŠ è½½å®Œæˆ
                loader.innerText = 'âœ¨ ç­‰å¾…æ¨¡å‹åŠ è½½...';
                await state.splatMesh.loaded;
                loader.innerText = 'âœ¨ æ¨¡å‹åŠ è½½å®Œæˆï¼';
                
                // è®¾ç½®è§†è§‰æ•ˆæœ
                setupSplatModifier(state.splatMesh, state.effectParams.effect);

                // å±…ä¸­æ¨¡å‹
                const box = new THREE.Box3().setFromObject(state.splatMesh);
                    const center = box.getCenter(new THREE.Vector3());
                state.splatMesh.position.sub(center);

                // è°ƒæ•´ç›¸æœºä½ç½®
                    const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                state.camera.position.set(0, 0, maxDim * 2);
                state.controls.target.copy(center);
                state.controls.update();

                // éšè—åŠ è½½æç¤º
                loader.style.display = 'none';
                loader.style.pointerEvents = 'none';

                // æ¸²æŸ“å¾ªç¯
                function animate(time) {
                    state.animationId = requestAnimationFrame(animate);
                    
                    // æ›´æ–°åŠ¨ç”»æ—¶é—´
                    state.baseTime += 1/60;
                    state.animateT.value = state.baseTime;
                    
                    // æ›´æ–° splat æ¸²æŸ“
                    if (state.splatMesh) {
                        state.splatMesh.updateVersion();
                    }
                    
                    // æ›´æ–°æ§åˆ¶å™¨å’Œæ¸²æŸ“
                    state.controls.update(state.camera);
                    state.renderer.render(state.scene, state.camera);
                }
                state.renderer.setAnimationLoop(animate);

                // å¤„ç†çª—å£å¤§å°å˜åŒ–
                const handleResize = () => {
                    if (state.camera && state.renderer) {
                        state.camera.aspect = window.innerWidth / window.innerHeight;
                        state.camera.updateProjectionMatrix();
                        state.renderer.setSize(window.innerWidth, window.innerHeight);
                    }
                };
                window.addEventListener('resize', handleResize);
                state.resizeHandler = handleResize; // ä¿å­˜å¼•ç”¨ä»¥ä¾¿æ¸…ç†

            } catch (err) {
                console.error('åŠ è½½æ¨¡å‹å¤±è´¥:', err);
                loader.innerText = 'âŒ åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ¨¡å‹æ–‡ä»¶';
                loader.style.display = 'flex';
                setTimeout(() => {
                    loader.style.display = 'none';
                }, 3000);
            }
        };

        // 4. ç‰©ç†åˆ é™¤é€»è¾‘ [web:31][web:79][web:83]
        document.getElementById('del-btn').onclick = async () => {
            const token = prompt("è¯·è¾“å…¥ HF Write Token ä»¥ç¡®è®¤åˆ é™¤ï¼š");
            if (!token || !confirm("æ°¸ä¹…åˆ é™¤è¯¥æ¨¡å‹åŠç…§ç‰‡ï¼Ÿ")) return;

            const operations = [
                { operation: "delete", path: state.currentLoc.photoPath },
                { operation: "addOrUpdate", path: "locations.json", content: new Blob([JSON.stringify(state.locations.filter(l => l.id !== state.currentLoc.id), null, 2)], {type:"application/json"}) }
            ];
            if (state.currentLoc.splatPath) operations.push({ operation: "delete", path: state.currentLoc.splatPath });

            try {
                await commit({ credentials: { accessToken: token }, repo: { type: "dataset", name: REPO_ID }, title: "Delete location", operations });
                location.reload();
            } catch (e) { alert("åˆ é™¤å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™ã€‚"); }
        };

        // ä¿å­˜ DeepL Key
        document.getElementById('deepl-key').value = state.deeplKey;
        document.getElementById('deepl-key').addEventListener('change', (e) => {
            state.deeplKey = e.target.value.trim();
            localStorage.setItem('DEEPL_KEY', state.deeplKey);
        });
        
        // è‡ªåŠ¨ç¿»è¯‘ï¼šå½“è¾“å…¥ä¸­æ–‡æè¿°æ—¶ï¼Œè‡ªåŠ¨ç¿»è¯‘ä¸ºè‹±æ–‡ï¼ˆä¿å­˜åˆ° state ä¸­ï¼‰
        let autoTranslatedDescEn = '';
        document.getElementById('desc-input').addEventListener('input', async (e) => {
            const descCn = e.target.value.trim();
            if (descCn && state.deeplKey) {
                autoTranslatedDescEn = await translateWithDeepL(descCn);
                console.log('âœ… æè¿°å·²è‡ªåŠ¨ç¿»è¯‘ä¸ºè‹±æ–‡');
            } else {
                autoTranslatedDescEn = '';
            }
        });
        
        // è‡ªåŠ¨ç¿»è¯‘ï¼šå½“è¾“å…¥ä¸­æ–‡åç§°æ—¶ï¼Œè‡ªåŠ¨ç¿»è¯‘ä¸ºè‹±æ–‡
        document.getElementById('loc-name').addEventListener('input', async (e) => {
            const nameCn = e.target.value.trim();
            const nameEnInput = document.getElementById('loc-name-en');
            if (nameCn && state.deeplKey && !nameEnInput.value.trim()) {
                nameEnInput.placeholder = 'æ­£åœ¨ç¿»è¯‘...';
                const translated = await translateWithDeepL(nameCn);
                nameEnInput.value = translated;
                nameEnInput.placeholder = 'Location Name (Englishï¼Œç•™ç©ºå°†è‡ªåŠ¨ç¿»è¯‘)';
            }
        });
        
        // 5. ä¸Šä¼ ä»»åŠ¡é€»è¾‘
        document.getElementById('submit-btn').onclick = async () => {
            const token = document.getElementById('hf-token').value.trim();
            const file = document.getElementById('photo-input').files[0];
            const name = document.getElementById('loc-name').value.trim();
            let nameEn = document.getElementById('loc-name-en').value.trim();
            const desc = document.getElementById('desc-input').value.trim();
            
            if (!token || !file || !state.selectedCoords || !name) {
                alert("è¯·å¡«å†™å®Œæ•´ä¿¡æ¯ï¼šTokenã€ç…§ç‰‡ã€åæ ‡å’Œä¸­æ–‡åç§°");
                return;
            }
            
            // å¦‚æœæ²¡æœ‰è‹±æ–‡åç§°ï¼Œå°è¯•ç¿»è¯‘
            if (!nameEn && state.deeplKey) {
                nameEn = await translateWithDeepL(name);
            }
            if (!nameEn) nameEn = name;
            
            // è·å–è‡ªåŠ¨ç¿»è¯‘çš„è‹±æ–‡æè¿°ï¼Œå¦‚æœæ²¡æœ‰åˆ™ç¿»è¯‘
            let descEn = autoTranslatedDescEn;
            if (!descEn && desc && state.deeplKey) {
                descEn = await translateWithDeepL(desc);
            }
            if (!descEn) descEn = desc || "";

            const ts = Date.now();
            const safeName = file.name.replace(/[^a-z0-9.]/gi, '_');
            const photoPath = `inputs/${ts}_${safeName}`;
            
            const newLoc = {
                id: ts,
                lat: state.selectedCoords.lat,
                lon: state.selectedCoords.lng,
                name: name,
                name_en: nameEn,
                desc: desc || "",
                desc_en: descEn,
                photoPath: photoPath,
                splatPath: "",
                status: "processing"
            };
            
            const newLocations = [...state.locations, newLoc];

            try {
                await commit({
                    credentials: { accessToken: token },
                    repo: { type: "dataset", name: REPO_ID },
                    title: `Upload task ${ts}`,
                    operations: [
                        { operation: "addOrUpdate", path: photoPath, content: file },
                        { operation: "addOrUpdate", path: "locations.json", content: new Blob([JSON.stringify(newLocations, null, 2)], {type:"application/json"}) }
                    ]
                });
                alert("ä»»åŠ¡ä¸Šä¼ æˆåŠŸï¼");
                document.getElementById('modal-overlay').style.display = 'none';
                // æ¸…ç©ºè¡¨å•ï¼ˆä¿ç•™ DeepL Keyï¼‰
                document.getElementById('hf-token').value = '';
                document.getElementById('loc-name').value = '';
                document.getElementById('loc-name-en').value = '';
                document.getElementById('lat-lon').value = '';
                document.getElementById('photo-input').value = '';
                document.getElementById('desc-input').value = '';
                autoTranslatedDescEn = '';
                state.selectedCoords = null;
                loadLocations();
            } catch (e) {
                alert("ä¸Šä¼ å¤±è´¥ï¼š" + (e.message || e));
            }
        };

        // 6. å…¶ä»–äº¤äº’é€»è¾‘ (æ‹¾å–ã€ä¸Šä¼ ã€AI)
        document.getElementById('upload-btn').onclick = () => document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('pick-btn').onclick = () => { document.getElementById('modal-overlay').style.display = 'none'; state.isPicking = true; };
        map.on('click', (e) => {
            if (state.isPicking) {
                state.selectedCoords = e.latlng;
                document.getElementById('lat-lon').value = `${e.latlng.lat.toFixed(4)}, ${e.latlng.lng.toFixed(4)}`;
                state.isPicking = false;
                document.getElementById('modal-overlay').style.display = 'flex';
            }
        });

        document.getElementById('close-splat').onclick = () => {
            document.getElementById('splat-viewer').style.display = 'none';
            // å…³é—­ 3D è§†å›¾æ—¶æ¢å¤åœ°å›¾å’Œ UI
            document.getElementById('ui-layer').style.display = 'block';
            document.getElementById('map-background').style.display = 'block';
            // éšè—æ•ˆæœæ§åˆ¶é¢æ¿
            const effectControls = document.getElementById('effect-controls');
            if (effectControls) {
                effectControls.style.display = 'none';
            }
            
            // æ¸…ç†èµ„æº
            if (state.animationId) {
                cancelAnimationFrame(state.animationId);
                state.animationId = null;
            }
            if (state.resizeHandler) {
                window.removeEventListener('resize', state.resizeHandler);
                state.resizeHandler = null;
            }
            if (state.controls) {
                state.controls.dispose();
                state.controls = null;
            }
            if (state.renderer) {
                const container = document.getElementById('splat-viewer');
                if (state.renderer.domElement && container.contains(state.renderer.domElement)) {
                    container.removeChild(state.renderer.domElement);
                }
                state.renderer.dispose();
                state.renderer = null;
            }
            if (state.splatMesh) {
                if (state.scene) {
                    state.scene.remove(state.splatMesh);
                }
                // å¦‚æœ SplatMesh æœ‰ dispose æ–¹æ³•ï¼Œè°ƒç”¨å®ƒ
                if (state.splatMesh.dispose) {
                    state.splatMesh.dispose();
                }
                state.splatMesh = null;
            }
            if (state.scene) {
                state.scene.clear();
                state.scene = null;
            }
            state.camera = null;
        };

        document.getElementById('save-key-btn').onclick = () => {
            const key = document.getElementById('user-gemini-key').value.trim();
            if (key) {
                ACTIVE_GEMINI_KEY = key;
                localStorage.setItem('MY_GEMINI_KEY', key);
                document.getElementById('gemini-config-ui').style.display = 'none';
                document.getElementById('chat-main-ui').style.display = 'flex';
                addChatMessage('agent', 'å¥½å‘€ï¼Œæˆ‘å·²ç»è¿ä¸Š Gemini äº†ï¼Œéšä¾¿é—®æˆ‘å…³äºè¿™ä¸ªåœºæ™¯çš„ä»»ä½•é—®é¢˜ï½');
            }
        };

        // èŠå¤©å‘é€æŒ‰é’®å’Œå›è½¦é”®
        document.getElementById('chat-send').onclick = () => { handleChat(); };
        document.getElementById('chat-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleChat();
            }
        });

        // è¯­è¨€åˆ‡æ¢æŒ‰é’®
        document.getElementById('lang-toggle').onclick = () => {
            state.lang = state.lang === 'cn' ? 'en' : 'cn';
            updateLangUI();
        };

        // æ•ˆæœé€‰æ‹©å™¨
        document.getElementById('effect-select').addEventListener('change', (e) => {
            const effect = e.target.value;
            state.effectParams.effect = effect;
            if (state.splatMesh) {
                setupSplatModifier(state.splatMesh, effect);
            }
        });

        loadLocations();
        setInterval(loadLocations, 20000);
        updateLangUI();
    </script>
</body>
</html>
